---
title: 线程
tags:
  - Note
  - Operating System
  - 操作系统
---
	线程包括：
	1.线程号 
	2.寄存器集合 ，包含PC程序计数器
	3.Stack,包括User Stack和Kernel Stack
	4.私有存储，被运行时库或DLL使用

后三项被称作Thread的Context
	
线程的好处：

	1.响应度。UI线程和费时的计算线程分开，提升响应度。
	2.资源共享。进程之间共享只能通过shared memeory或message passing。线程默认共享内存和资源。
	3.经济。线程的创建与上下文切换相比进程更快。
	4.拓展性（Scalability）。多线程在多核处理器下，可以充分利用处理器。

//多核与多处理器的区别。多核可能在一个芯片上，多处理器则是多个独立的cpu。

**Parallelism vs Concurrency**
Parallel 表示一个系统可以**同时**运行多个任务。
Concurrent表示一个系统可以使多个任务都取得运作。

在SMP和多核之前，单处理器在进程之间使用快速上下文切换来提供一种parallel的假象。

并行编程的挑战：
	1.identify task。合理分割任务，使并行。
	2.balance。各个任务运算平衡。
	3.data splitting
	4.data dependency
	5.test and debug

//  AMDAHL’S LAW  ???

并行的分类：
1.数据并行。比如两个线程分别求和数组的两半。
2.任务并行。



## 线程模型

**多对一**

多个用户线程对应一个内核线程。当一个用户线程进行阻塞系统调用，对应内核线程阻塞，整个进程就会阻塞。缺点：无法利用多核系统实现并行。eg。Solaris的Green Threads.


**一对一**

一个用户线程对应一个内核线程。缺点：因为一对一，系统支持的线程数量会有限制。eg.Linux和windows


**多对多**

内核线程数小于等于用户线程数。优势：线程数无限制，充分利用多核。


## 线程库

两种线程库：
1.纯粹在用户空间实现，无内核支持。调用库函数不会发生系统调用。
2.在内核空间实现，库的代码数据在内核存在。会发生系统调用。


三种主流线程库：POSIX Pthreads,Windows,Java。

Pthreads: 用户、内核
Windows：内核
Java:取决于宿主系统，在Windows用windows api，Linux/Unix 用Pthreads


windows ，linux下线程共享全局数据。然而在Java下，没有全局数据的概念，线程间共享数据需要额外的准备。

线程创建的两种模型：

1.异步。 创建后，并发执行。通常，数据共享比较少。
2.同步。 创建后，父线程等待子线程终止。

Note.
Pthread是POSIX 的一个线程行为标准，具体实现取决于系统设计者。比如Linux,MAC OS，Solaris。

创建线程


Linux

```cpp
// Linux
#include <pthread.h>
#include <stdio.h>
int sum; /* this data is shared by the thread(s) */
// void func(void *)类型的函数指针
void *runner(void *param); /* threads call this function */
int main(int argc, char *argv[])
{
    pthread_t tid; /* the thread identifier */
    pthread_attr_t attr; /* set of thread attributes */
    if (argc != 2) {
        fprintf(stderr,"usage: a.out <integer value>\n");
        return -1;
    }
    if (atoi(argv[1]) < 0) {
        fprintf(stderr,"%d must be >= 0\n",atoi(argv[1]));
        return -1;
    }
    /* get the default attributes */
    pthread_attr_init(&attr);
    /* create the thread */
    pthread_create(&tid,&attr,runner,argv[1]);
    /* wait for the thread to exit */
    pthread_join(tid,NULL);
    printf("sum = %d\n",sum);
}
/* The thread will begin control in this function */
void *runner(void *param)
{
    int i, upper = atoi(param);
    sum = 0;
    for (i = 1; i <= upper; i++)
        sum += i;   
    pthread exit(0);
}
```

Linux同时提供clone()系统调用创建线程。Linux常用Task来表述一个程序的控制流。当调用clone时附带共享内存等Flags时，等同于创建线程，当没有共享Flags时，等同于fork()创建线程。这样，各种程度的共享是可以实现的，

| flag          | 意义             |
| ------------- | ---------------- |
| CLONE_FS      | 共享文件系统信息 |
| CLONE_VM      | 共享内存空间     |
| CLONE_SIGHAND | 共享信号handles  |
|CLONE_FILES               | 共享打开的文件   |


Windows

```cpp
\\windows
#include <windows.h>
#include <stdio.h>
DWORD Sum; /* data is shared by the thread(s) */
/* the thread runs in this separate function */
DWORD WINAPI Summation(LPVOID Param)
{
    DWORD Upper = *(DWORD*)Param;
    for (DWORD i = 0; i <= Upper; i++)
        Sum += i;
    return 0;
}
int main(int argc, char *argv[])
{
    DWORD ThreadId;
    HANDLE ThreadHandle;
    int Param;
    if (argc != 2) {
        fprintf(stderr,"An integer parameter is required\n");
        return -1;
    }
    Param = atoi(argv[1]);
    if (Param < 0) {
        fprintf(stderr,"An integer >= 0 is required\n");
    return -1;
}
/* create the thread */
ThreadHandle = CreateThread(
                            NULL, /* default security attributes */
                            0, /* default stack size */
                            Summation, /* thread function */
                            &Param, /* parameter to thread function */
                            0, /* default creation flags */
                            &ThreadId); /* returns the thread identifier */
if (ThreadHandle != NULL) {
    /* now wait for the thread to finish */
    WaitForSingleObject(ThreadHandle,INFINITE);
    /* close the thread handle */
    CloseHandle(ThreadHandle);
    printf("sum = %d\n",Sum);
}
}
```
JAVA

```java
//JAVA
class Sum
{
    private int sum;
    public int getSum() {
        return sum;
    }
    public void setSum(int sum) {
        this.sum = sum;
    }
}
class Summation implements Runnable
{
    private int upper;
    private Sum sumValue;
    public Summation(int upper, Sum sumValue) {
        this.upper = upper;
        this.sumValue = sumValue;
    }
    public void run() {
        int sum = 0;
        for (int i = 0; i <= upper; i++)
            sum += i;
        sumValue.setSum(sum);
    }
}
public class Driver
{
    public static void main(String[] args) {
        if (args.length > 0) {
            if (Integer.parseInt(args[0]) < 0)
                System.err.println(args[0] + " must be >= 0.");
            else {
                Sum sumObject = new Sum();
                int upper = Integer.parseInt(args[0]);
                Thread thrd = new Thread(new Summation(upper, sumObject));
                thrd.start();
                try {
                    thrd.join();
                    System.out.println
                    ("The sum of "+upper+" is "+sumObject.getSum());
                } catch (InterruptedException ie) { }
            }
        }
        else
            System.err.println("Usage: Summation <integer value>"); }
}
```

### Implicit Threading

Implicit Threading:将进程的创建与管理交给编译器与运行时库。

方法:
1.Thread Pools
2.OpenMP
3.GCD
4..

#### 线程池 Thread Pools

理念：在进程创建时初始化一定数量的线程，并置于线程池。当需要线程，从线程池激活一个线程，并工作，等其完成则返回线程池等待新的工作。如果线程池没有空闲线程，则等待。

好处：
1.响应请求速度提升，已经创建好的线程比新创建线程速度快。
2.限制了线程数量，防止超过系统承受。


windows 
```cpp
DWORD WINAPI PoolFunction(AVOID Param) {
/*
* this function runs as a separate thread.
*/
}

QueueUserWorkItem(&PoolFunction, NULL, 0);
```

#### OpenMP

OpenMP是一套支持C/C++，FORTRAN 并行编程的编译器伪指令，api。
```cpp
#include <omp.h>
#include <stdio.h>
int main(int argc, char *argv[])
{
    /* sequential code */
    #pragma omp parallel
    {
        printf("I am a parallel region.");
    }
    /* sequential code */
    return 0;
}
```

#### Grand Central Dispatch

MAC OS X与iOS。

```cpp
ˆ{ printf("I am a block"); }
```


Note.
POSIX是一套api标准，遵循此标准的操作系统为POSIX操作系统，The Portable Operating System Interface。

链接：
[POSIX api1][1]
[POSIX api2][2] 
[标准C库][3]


### 线程与进程复制

fork()在多线程下，有可能复制所有线程，或只复制调用fork()的线程。如果fork()后会exec()则调用后者，即只复制单一线程比较经济。否则，前者更为适用。

exec()在多线程下，直接替换整个进程，包括所有线程。

### 信号处理

Unix下，信号用于通知进程特定事件发生了。取决于信号源或信号发送原因，信号是同步或者异步的。

信号必须被处理。

同步信号:异常内存访问，除0错误等。

异步信号：由进程外部事件产生，比如ctrl +C.

信号到底应该发送给特定线程还是所有线程，取决于信号种类。

`kill(pid_t pid, int signal)`Unix发送信号`pthread_kill(pthread_t tid, int signal)`

Windows用asynchronous procedure calls (APC)模拟异步信号。


### 线程取消

目标线程(target thread):要被取消的线程

取消方式：
1.异步：一个线程立即取消目标线程
2.延期的(deferred)：目标线程周期性检查是否应该终结，给其一个可以稍晚取消的机会。

线程取消的难点在于目标线程存在与其他线程共享的资源

POSIX`pthread_create(&tid, 0, worker, NULL);`只是发起取消请求，具体如何取消，取决于线程的handle。

| Mode | State    | Type |
| ---- | -------- | ---- |
| Off  | Disabled | -    |
| 异步 | Enabled  | 异步 |
| 延期 | Enabled  | 延期    |


默认类型为“延期”，到达取消点(cancellation point)的时候，会被取消。
`pthread_testcancel()`用于测试取消点。在取消之前cleanup handler函数会被调用以释放分配的资源。

```cpp
while (1) {
/* do some work for awhile */
/* ... */
/* check if there is a cancellation request */
	pthread_testcancel();
}
```

### 线程本地存储

在特定情况下，线程需要私有的数据，即Thread Local Storage.TLS不同于局部变量，后者只函数内存在。TLS有点类似static变量，但是TLS对线程唯一。


### Scheduler Activations

//TODO ????


### LWP 轻权进程

//TODO



---
title: 进程 
tags:
  - Note
  - 操作系统
  - process
  - Operting System
---


**进程的状态：**

    New. The process is being created.
    Running. Instructions are being executed.
    Waiting. The process is waiting for some event to occur (such as an I/O
              completion or reception of a signal).
    Ready. The process is waiting to be assigned to a processor.
    Terminated. The process has finished execution.

![进程状态][1]

**Process Control Block 进程控制块**

包含内容：
1.进程状态
2.程序计数器
3.CPU寄存器
4.CPU调度信息：进程优先级，调度队列指针等
5.内存管理信息：根据操作系统内存管理方式，可能包含base ，limit寄存器或者页表等信息。
6.台帐信息：CPU使用时间，进程数量等。
7.IO状态信息：分配的IO设备，打开的文件等。


**Scheduling Queues 调度队列**

Ready Queue:*内存中* 等待执行的进程队列。

Device Queue：等待特定IO设备的进程队列。

![调度队列][2]


**Scheduler 调度器**

进程在执行过程中在各个调度队列间迁移。调度器负责这个迁移过程。

调度器分类：
1. 长期调度器：如在批处理系统中，大量的进程被存储在大容量存储设备上，长期调度器从这些进程中选择。
2.短期调度器(CPU 调度器)：从内存中的进程选择进行调度。两次调度间隔很短，小于100ms。
3.中期调度器：会牺牲多任务能力，将进程置换到外存。

IO bound process:花费在IO上的时间多于CPU
CPU bound process:花费在CPU的时间多于IO

**Context Switch 上下文切换**

高度依赖硬件支持。


**父进程与子进程**

**进程创建**

子进程可能从操作系统直接获得资源，或继承部分父进程资源。

创建子进程后可能：1.父子并发运行 2.父进程等待子进程结束。

子进程地址空间可能变化：1.父进程的复制 2.加载新程序 （exec）


**进程终结**

exit(status)返回值。 
pid = wait(&status) 收集返回值。

**Cacading Termination 级联终止**
终止一个进程将会终止其下所以子进程。


**Zombie Process 僵尸进程**
未被父进程用wait()收集的进程。在未被wait之前，该进程的exit status一直保存在进程表中。

**Orphan Process 孤儿进程**
父进程终结，而未被终结的进程。Linux，Unix会将Orphan 赋给init进程，init进程会周期性地调用wait收集终结进程状态。

**独立进程、协作进程**
独立进程无法影响，或被操作系统内的其他进程影响。进程协作需要IPC（interprocess communication）。

Chrome 多进程设计
![Chrome浏览器][3]


# **IPC 跨进程通讯**

1.shared memory
2.message passing


## **shared memory**
```cpp
// common part
#define BUFFER SIZE 10
typedef struct {
...
}item;
item buffer[BUFFER SIZE];
int in = 0;
int out = 0;

// producer
while (true) {
/* produce an item in next produced */
    while (((in + 1) % BUFFER SIZE) == out)
    ; /* do nothing */
    buffer[in] = next produced;
    in = (in + 1) % BUFFER SIZE;
}

// consumer
item next consumed;
while (true) {
    while (in == out)
    ; /* do nothing */
    next consumed = buffer[out];
    out = (out + 1) % BUFFER SIZE;
    /* consume the item in next consumed */
}
```


## **message passing**

 - Direct or indirect communication 通信方式
 - Synchronous or asynchronous communication 同步方式
 - Automatic or explicit buffering 缓冲方式


### 直接通信、间接通信

直接通信：

对称式
send(P, message)—Send a message to process P.
receive(Q, message)—Receive a message from process Q

不对称式：
send(P, message)—Send a message to process P.
receive(id, message)—Receive a message from any process. The
variable id is set to the name of the process with which communication
has taken place.

两种方法的缺点都是需要硬编码进程号。

间接通信

进程间通过邮箱mailbox或端口port通信。

区别于直接通信：一个通信链路可能关联多个进程。两个进程之间可能有多个通信链路（mailbox）。

send(A, message)—Send a message to mailbox A.
receive(A, message)—Receive a message from mailbox A.

一个邮箱mailbox可能被一个进程拥有（即在该进程的地址空间）或者被操作系统拥有。邮箱拥有者接收信息。在操作系统拥有情况下，创建该邮箱的进程拥有该邮箱，邮箱所有权可以转移。

### 同步方式

阻塞式、非阻塞式（也称同步、异步）

阻塞式 
发：发送进程等接收进程接或邮箱收到信息才停止阻塞。
收：接收到信息才停止阻塞。

非阻塞式：
发：发送消息，恢复执行。
收：接收到消息或者null。

### 缓冲方式

无论直接、间接通信都需要临时队列缓冲数据。

 - 0 容量：发送方必须阻塞直到对方接收。
 - 有限长度容量：发送方在full满时会阻塞。
 - 无限长度容量：发送方永不阻塞。

windows 的ALPC(Advanced Local Procedure Call)实现IPC。

C/S 系统通信方式：
1. shared memory
2. message passing
3. sockets
4. RPC(remote procedure call)
5. Pipe


**RPC**
相比于IPC，RPC具有消息结构，消息发送到对应端口，内容包括需要调用的函数，以及参数，该参数会如期调用，结果将会以消息形式返回。RPC服务将绑定在端口上。为了使进程像LPC一样调用RPC，客户端会提供stub。windows上stub 代码Microsoft Interface Definition Language(MIDL)。
external data representation确定传输数据格式.

困难1：如何保证RPC只执行一次。
在消息上附加时间戳，服务端保存RPC的调用历史，每次核对时间戳，如果不重复则调用。同时，服务端返回ACK保证只执行一次。

困难2：如何绑定RPC
方法1.在编译时绑定服务端端口，固定端口。
方法2.服务端操作系提供汇合机制，服务端提供rendezvous (also called a matchmaker) daemon，该进程固定端口。客户端发送RPC请求到该端口，该端口返回RPC端口号。


**Pipe**

1.单向管道、双向管道
2.如果双向，是全双工还是半双工
3.两个进程之间是否必须为父子关系
4.是否可以跨网络通信

1.普通管道 Orinary Pipe
  单向，父子进程。
  unix `pipe(int fd[])` windows `CreatePipe()`

2.命名管道 Named Pie
  双向，非父子进程。进程终结后依然存在。
  unix上被称作FIFO `mkfifo()`双向，半双工。




  [1]: https://www.github.com/ChristopherKai/picsRepo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1519435567265.jpg
  [2]: https://www.github.com/ChristopherKai/picsRepo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1519436269757.jpg
  [3]: https://www.github.com/ChristopherKai/picsRepo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1519482975976.jpg
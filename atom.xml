<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Kais&#39; Blog</title>
  <icon>https://www.gravatar.com/avatar/cb9bcdd30842e74b052ce084a1e6a8d6</icon>
  <subtitle>hello</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://kaisblog.cn/"/>
  <updated>2018-05-20T07:57:22.383Z</updated>
  <id>http://kaisblog.cn/</id>
  
  <author>
    <name>kais</name>
    <email>hjuj_91@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>sqlmap 指南</title>
    <link href="http://kaisblog.cn/2018/05/20/sqlmap%E6%8C%87%E5%8D%97/"/>
    <id>http://kaisblog.cn/2018/05/20/sqlmap指南/</id>
    <published>2018-05-20T07:57:22.382Z</published>
    <updated>2018-05-20T07:57:22.383Z</updated>
    
    <content type="html"><![CDATA[<h2 id="sql注入介绍："><a href="#sql注入介绍：" class="headerlink" title="sql注入介绍："></a>sql注入介绍：</h2><p>假设需要审计的网站根据get，post，cookie，user-agent生成动态网页，现需测试其是否存在sql 注入漏洞。</p><p>若<code>http://192.168.136.131/sqlmap/mysql/get_int.php?id=1+AND+1=1</code>页面内容与<code>http://192.168.136.131/sqlmap/mysql/get_int.php?id=1+AND+1=2</code>页面内容不同，则显示该页面可能存在sql注入漏洞。</p><p>基本概念：</p><p>盲注(blind injection)：无法看到测试SQL语句的回显调试信息的注入方法。</p><p>延时注入：在无法判断测试SQL语句是否被执行的情况下，利用BENCHMARK()函数判断SQL语句是否被执行，寻找注入点。</p><p><a href="https://malware.expert/general/what-is-a-web-shell/" target="_blank" rel="external">webshell</a>：攻击者用目标网站所支持的编程语言编写的脚本，存储在目标网站服务器上，可以用来操作目标网站。</p><p>Note.<br>对于NoSQL，可以使用NoSQLmap进行注入。</p><h2 id="注入探测"><a href="#注入探测" class="headerlink" title="注入探测"></a>注入探测</h2><h3 id="Get请求"><a href="#Get请求" class="headerlink" title="Get请求"></a>Get请求</h3><p><code>sqlmap.py -u url</code></p><h3 id="Post请求"><a href="#Post请求" class="headerlink" title="Post请求"></a>Post请求</h3><p><code>sqlmp.py -u url --data={key=value}</code></p><h3 id="cookie方式"><a href="#cookie方式" class="headerlink" title="cookie方式"></a>cookie方式</h3><p><code>sqlmap.py -u url --cookie={cookie}</code></p><h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p><strong>获取数据库名</strong> <code>--current-db</code></p><p><strong>获取用户名</strong> <code>--current-user</code></p><p><strong>获取数据量</strong><code>--count -D {databaseName}</code></p><p><strong>获取当前用户权限</strong><code>--privileges</code></p><p><strong>延时注入</strong><code>--delay {delayTime}</code></p><p><strong>上传webshell</strong><code>--os-shell</code></p><p><strong>上传本地文件到服务器</strong><code>--file-write={localFile} --file-dest={destPath}</code></p><p><strong>利用文本文件批量检测</strong>(<a href="https://github.com/sqlmapproject/sqlmap/wiki/Usage#scan-multiple-targets-enlisted-in-a-given-textual-file)`-m`" target="_blank" rel="external">https://github.com/sqlmapproject/sqlmap/wiki/Usage#scan-multiple-targets-enlisted-in-a-given-textual-file)`-m`</a></p><p><a href="https://github.com/sqlmapproject/sqlmap/wiki/Usage#parse-targets-from-burp-or-webscarab-proxy-logs" target="_blank" rel="external"><strong>利用burp suite日志进行批量检测</strong></a><code>-l</code></p><p><strong>verbose模式</strong>显示攻击载荷，http请求，响应等。<code>-v {0-6}</code></p><p><strong>指定代理</strong>转发到burp suite进行攻击，<code>--proxy={}</code></p><p>Note.</p><p>Microsoft SQL server 最高权限用户名:sa<br>MySQL 最高权限用户名:root</p><h2 id="攻击载荷"><a href="#攻击载荷" class="headerlink" title="攻击载荷"></a>攻击载荷</h2><p>载荷目录xml/payloads</p><h2 id="测试等级"><a href="#测试等级" class="headerlink" title="测试等级"></a>测试等级</h2><p>使用<code>--level=2</code> 指定等级，一般高一点。<br>等级为2，测试cookie。<br>等级为3，测试User-Agent，Referer。</p><h2 id="风险等级"><a href="#风险等级" class="headerlink" title="风险等级"></a>风险等级</h2><p>使用<code>--risk=2</code>指定，一般低一点。</p><p>共有3个风险等级。</p><ul><li>等级1，无风险。</li><li>等级2，会执行耗时数据库操作。</li><li>等级3，加入OR语句。比如Update语句中加入OR，可能导致整个数据表更改。</li></ul><h2 id="SQL注入常规流程"><a href="#SQL注入常规流程" class="headerlink" title="SQL注入常规流程"></a>SQL注入常规流程</h2><ol><li>获取库名<code>--current-db</code></li><li>获取表名<code>--table -D &quot;{databaseName}&quot;</code></li><li>获取列名<code>--columns -T &quot;{tableName}&quot; -D &quot;{databaseName}&quot;</code></li><li><p>获取某列字段所有值<code>-C &quot;{columnName}&quot; -T &quot;{tableName}&quot; -D &quot;{databaseName}&quot; --dump</code></p><h2 id="直连自己的数据库"><a href="#直连自己的数据库" class="headerlink" title="直连自己的数据库"></a>直连自己的数据库</h2><p><code>-d &quot;mysql://account:password@address:port/databaseName&quot;</code></p><p>打开数据库的shell:<code>--sql-shell</code></p></li></ol><h2 id="tamper脚本"><a href="#tamper脚本" class="headerlink" title="tamper脚本"></a>tamper脚本</h2><p>tamper脚本支持高级的注入，如绕过WAF(web application Firewall)。</p><p><code>--tamper={scriptName}</code></p><h2 id="sqlmap目录结构"><a href="#sqlmap目录结构" class="headerlink" title="sqlmap目录结构"></a>sqlmap目录结构</h2><p><img src="./images/1526699051623.jpg" alt="目录结构"></p><h2 id="sqlmap支持的注入技术"><a href="#sqlmap支持的注入技术" class="headerlink" title="sqlmap支持的注入技术"></a>sqlmap支持的注入技术</h2><h3 id="布尔值盲注"><a href="#布尔值盲注" class="headerlink" title="布尔值盲注"></a>布尔值盲注</h3><p>// TODO</p><p><a href="https://del.icio.us/inquis/sqlinjection" target="_blank" rel="external">sql注入资料</a></p><p><a href="https://www.youtube.com/user/inquisb/videos" target="_blank" rel="external">sqlmap官方视频教程</a></p><p><a href="https://github.com/sqlmapproject/sqlmap/wiki/Usage" target="_blank" rel="external">sqlmap使用说明</a></p><p>在DWVA下测试sql注入：<br><a href="https://www.youtube.com/watch?v=5BG6iq_AUvM" target="_blank" rel="external">DVWA安装方法</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;sql注入介绍：&quot;&gt;&lt;a href=&quot;#sql注入介绍：&quot; class=&quot;headerlink&quot; title=&quot;sql注入介绍：&quot;&gt;&lt;/a&gt;sql注入介绍：&lt;/h2&gt;&lt;p&gt;假设需要审计的网站根据get，post，cookie，user-agent生成动态网页，现需
      
    
    </summary>
    
    
      <category term="CTF" scheme="http://kaisblog.cn/tags/CTF/"/>
    
      <category term="security" scheme="http://kaisblog.cn/tags/security/"/>
    
      <category term="web" scheme="http://kaisblog.cn/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>进程</title>
    <link href="http://kaisblog.cn/2018/05/20/%E8%BF%9B%E7%A8%8B/"/>
    <id>http://kaisblog.cn/2018/05/20/进程/</id>
    <published>2018-05-20T01:45:49.938Z</published>
    <updated>2018-05-20T01:45:49.939Z</updated>
    
    <content type="html"><![CDATA[<p><strong>进程的状态：</strong></p><pre><code>New. The process is being created.Running. Instructions are being executed.Waiting. The process is waiting for some event to occur (such as an I/O          completion or reception of a signal).Ready. The process is waiting to be assigned to a processor.Terminated. The process has finished execution.</code></pre><p><img src="https://www.github.com/ChristopherKai/picsRepo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1519435567265.jpg" alt="进程状态"></p><p><strong>Process Control Block 进程控制块</strong></p><p>包含内容：<br>1.进程状态<br>2.程序计数器<br>3.CPU寄存器<br>4.CPU调度信息：进程优先级，调度队列指针等<br>5.内存管理信息：根据操作系统内存管理方式，可能包含base ，limit寄存器或者页表等信息。<br>6.台帐信息：CPU使用时间，进程数量等。<br>7.IO状态信息：分配的IO设备，打开的文件等。</p><p><strong>Scheduling Queues 调度队列</strong></p><p>Ready Queue:<em>内存中</em> 等待执行的进程队列。</p><p>Device Queue：等待特定IO设备的进程队列。</p><p><img src="https://www.github.com/ChristopherKai/picsRepo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1519436269757.jpg" alt="调度队列"></p><p><strong>Scheduler 调度器</strong></p><p>进程在执行过程中在各个调度队列间迁移。调度器负责这个迁移过程。</p><p>调度器分类：</p><ol><li>长期调度器：如在批处理系统中，大量的进程被存储在大容量存储设备上，长期调度器从这些进程中选择。<br>2.短期调度器(CPU 调度器)：从内存中的进程选择进行调度。两次调度间隔很短，小于100ms。<br>3.中期调度器：会牺牲多任务能力，将进程置换到外存。</li></ol><p>IO bound process:花费在IO上的时间多于CPU<br>CPU bound process:花费在CPU的时间多于IO</p><p><strong>Context Switch 上下文切换</strong></p><p>高度依赖硬件支持。</p><p><strong>父进程与子进程</strong></p><p><strong>进程创建</strong></p><p>子进程可能从操作系统直接获得资源，或继承部分父进程资源。</p><p>创建子进程后可能：1.父子并发运行 2.父进程等待子进程结束。</p><p>子进程地址空间可能变化：1.父进程的复制 2.加载新程序 （exec）</p><p><strong>进程终结</strong></p><p>exit(status)返回值。<br>pid = wait(&amp;status) 收集返回值。</p><p><strong>Cacading Termination 级联终止</strong><br>终止一个进程将会终止其下所以子进程。</p><p><strong>Zombie Process 僵尸进程</strong><br>未被父进程用wait()收集的进程。在未被wait之前，该进程的exit status一直保存在进程表中。</p><p><strong>Orphan Process 孤儿进程</strong><br>父进程终结，而未被终结的进程。Linux，Unix会将Orphan 赋给init进程，init进程会周期性地调用wait收集终结进程状态。</p><p><strong>独立进程、协作进程</strong><br>独立进程无法影响，或被操作系统内的其他进程影响。进程协作需要IPC（interprocess communication）。</p><p>Chrome 多进程设计<br><img src="https://www.github.com/ChristopherKai/picsRepo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1519482975976.jpg" alt="Chrome浏览器"></p><h1 id="IPC-跨进程通讯"><a href="#IPC-跨进程通讯" class="headerlink" title="IPC 跨进程通讯"></a><strong>IPC 跨进程通讯</strong></h1><p>1.shared memory<br>2.message passing</p><h2 id="shared-memory"><a href="#shared-memory" class="headerlink" title="shared memory"></a><strong>shared memory</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// common part</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER SIZE 10</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">...</span><br><span class="line">&#125;item;</span><br><span class="line">item buffer[BUFFER SIZE];</span><br><span class="line"><span class="keyword">int</span> in = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> out = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// producer</span></span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line"><span class="comment">/* produce an item in next produced */</span></span><br><span class="line">    <span class="keyword">while</span> (((in + <span class="number">1</span>) % BUFFER SIZE) == out)</span><br><span class="line">    ; <span class="comment">/* do nothing */</span></span><br><span class="line">    buffer[in] = next produced;</span><br><span class="line">    in = (in + <span class="number">1</span>) % BUFFER SIZE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// consumer</span></span><br><span class="line">item next consumed;</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">while</span> (in == out)</span><br><span class="line">    ; <span class="comment">/* do nothing */</span></span><br><span class="line">    next consumed = buffer[out];</span><br><span class="line">    out = (out + <span class="number">1</span>) % BUFFER SIZE;</span><br><span class="line">    <span class="comment">/* consume the item in next consumed */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="message-passing"><a href="#message-passing" class="headerlink" title="message passing"></a><strong>message passing</strong></h2><ul><li>Direct or indirect communication 通信方式</li><li>Synchronous or asynchronous communication 同步方式</li><li>Automatic or explicit buffering 缓冲方式</li></ul><h3 id="直接通信、间接通信"><a href="#直接通信、间接通信" class="headerlink" title="直接通信、间接通信"></a>直接通信、间接通信</h3><p>直接通信：</p><p>对称式<br>send(P, message)—Send a message to process P.<br>receive(Q, message)—Receive a message from process Q</p><p>不对称式：<br>send(P, message)—Send a message to process P.<br>receive(id, message)—Receive a message from any process. The<br>variable id is set to the name of the process with which communication<br>has taken place.</p><p>两种方法的缺点都是需要硬编码进程号。</p><p>间接通信</p><p>进程间通过邮箱mailbox或端口port通信。</p><p>区别于直接通信：一个通信链路可能关联多个进程。两个进程之间可能有多个通信链路（mailbox）。</p><p>send(A, message)—Send a message to mailbox A.<br>receive(A, message)—Receive a message from mailbox A.</p><p>一个邮箱mailbox可能被一个进程拥有（即在该进程的地址空间）或者被操作系统拥有。邮箱拥有者接收信息。在操作系统拥有情况下，创建该邮箱的进程拥有该邮箱，邮箱所有权可以转移。</p><h3 id="同步方式"><a href="#同步方式" class="headerlink" title="同步方式"></a>同步方式</h3><p>阻塞式、非阻塞式（也称同步、异步）</p><p>阻塞式<br>发：发送进程等接收进程接或邮箱收到信息才停止阻塞。<br>收：接收到信息才停止阻塞。</p><p>非阻塞式：<br>发：发送消息，恢复执行。<br>收：接收到消息或者null。</p><h3 id="缓冲方式"><a href="#缓冲方式" class="headerlink" title="缓冲方式"></a>缓冲方式</h3><p>无论直接、间接通信都需要临时队列缓冲数据。</p><ul><li>0 容量：发送方必须阻塞直到对方接收。</li><li>有限长度容量：发送方在full满时会阻塞。</li><li>无限长度容量：发送方永不阻塞。</li></ul><p>windows 的ALPC(Advanced Local Procedure Call)实现IPC。</p><p>C/S 系统通信方式：</p><ol><li>shared memory</li><li>message passing</li><li>sockets</li><li>RPC(remote procedure call)</li><li>Pipe</li></ol><p><strong>RPC</strong><br>相比于IPC，RPC具有消息结构，消息发送到对应端口，内容包括需要调用的函数，以及参数，该参数会如期调用，结果将会以消息形式返回。RPC服务将绑定在端口上。为了使进程像LPC一样调用RPC，客户端会提供stub。windows上stub 代码Microsoft Interface Definition Language(MIDL)。<br>external data representation确定传输数据格式.</p><p>困难1：如何保证RPC只执行一次。<br>在消息上附加时间戳，服务端保存RPC的调用历史，每次核对时间戳，如果不重复则调用。同时，服务端返回ACK保证只执行一次。</p><p>困难2：如何绑定RPC<br>方法1.在编译时绑定服务端端口，固定端口。<br>方法2.服务端操作系提供汇合机制，服务端提供rendezvous (also called a matchmaker) daemon，该进程固定端口。客户端发送RPC请求到该端口，该端口返回RPC端口号。</p><p><strong>Pipe</strong></p><p>1.单向管道、双向管道<br>2.如果双向，是全双工还是半双工<br>3.两个进程之间是否必须为父子关系<br>4.是否可以跨网络通信</p><p>1.普通管道 Orinary Pipe<br>  单向，父子进程。<br>  unix <code>pipe(int fd[])</code> windows <code>CreatePipe()</code></p><p>2.命名管道 Named Pie<br>  双向，非父子进程。进程终结后依然存在。<br>  unix上被称作FIFO <code>mkfifo()</code>双向，半双工。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;进程的状态：&lt;/strong&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;New. The process is being created.
Running. Instructions are being executed.
Waiting. The process 
      
    
    </summary>
    
    
      <category term="Note" scheme="http://kaisblog.cn/tags/Note/"/>
    
      <category term="操作系统" scheme="http://kaisblog.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="process" scheme="http://kaisblog.cn/tags/process/"/>
    
      <category term="Operting System" scheme="http://kaisblog.cn/tags/Operting-System/"/>
    
  </entry>
  
  <entry>
    <title>虚拟存储技术</title>
    <link href="http://kaisblog.cn/2018/05/20/%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E6%8A%80%E6%9C%AF/"/>
    <id>http://kaisblog.cn/2018/05/20/虚拟存储技术/</id>
    <published>2018-05-20T01:45:49.937Z</published>
    <updated>2018-05-20T01:45:49.938Z</updated>
    
    <content type="html"><![CDATA[<h1 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h1><h3 id="虚拟内存解决的问题："><a href="#虚拟内存解决的问题：" class="headerlink" title="虚拟内存解决的问题："></a>虚拟内存解决的问题：</h3><p>原有的内存管理方式需要把整个程序加载到内存空间，如果只将程序的一部分加载到内存空间，有着以下优势：</p><p>1.程序大小不再决定于物理内存大小，计算机可以运行大于物理内存的程序<br>2.计算机可以运行的程序增加，提示cpu利用率，吞吐量<br>3.更少的置换I/O，不需swap in/out</p><h3 id="虚拟内存的前提："><a href="#虚拟内存的前提：" class="headerlink" title="虚拟内存的前提："></a>虚拟内存的前提：</h3><p>1.程序的错误处理部分不会经常发生，可以开始不加载<br>2.数组等数据结构分配的内存空间大于实际使用的内存空间<br>3.程序的特定功能很少被使用。比如美国政府电脑上平衡财政预算的程序部分。</p><h2 id="demand-paging"><a href="#demand-paging" class="headerlink" title="demand paging"></a>demand paging</h2><p>Concept:To load pages only as they are needed.</p><p>demand paging 引发诸多架构困难。</p><h3 id="等效访问时间："><a href="#等效访问时间：" class="headerlink" title="等效访问时间："></a>等效访问时间：</h3><p>effective access time = (1 − p) × ma + p × page fault time.<br>p be the probability of a page fault (0 ≤ p ≤ 1)<br>the memory-access time, denoted ma</p><h3 id="Page-Fault-服务程序"><a href="#Page-Fault-服务程序" class="headerlink" title="Page Fault 服务程序"></a>Page Fault 服务程序</h3><pre><code>1. Service the page-fault interrupt. 2. Read in the page. 3. Restart the process.</code></pre><p>硬盘上的置换分区（swap space）由于特殊的结构，访问速度比文件系统更快。</p><h3 id="demand-paging请求调页实现方法"><a href="#demand-paging请求调页实现方法" class="headerlink" title="demand paging请求调页实现方法"></a>demand paging请求调页实现方法</h3><pre><code>1.加载进程前，将整个程序加载到置换分区，然后demand paging2.将程序从文件系统按需加载，当页面被置换的时候，将页面写入置换分区。这种方法保证了只有所需的页面从文件系统加载，后续的paging从置换分区进行。3.需求页面从文件系统加载，当页面置换时，原有页面会被覆盖（因为是纯代码，需求时可从文件系统加载），置换分区主要负责heap，stack等内存页面（被称作匿名内存）。备用于Solaris和BSD Linux。</code></pre><p>移动设备操作系统不支持换页swapping，当需求页面时，直接从文件系统加载。当内存不足时，直接回收只读纯代码页面。<br>在iOS下，匿名内存页面永不回收，除非应用被终止或明确释放内存。</p><p>总结，方法3类似移动设备的解决方案，都从文件系统加载，内存不足都会直接覆盖页面，该页面再需求时，再从文件系统加载。区别于，方法3会将匿名内存swap到置换分区上，移动设备则几乎永远保留。</p><h4 id="Note"><a href="#Note" class="headerlink" title="Note."></a>Note.</h4><p>fork()创建新进程可以不需要demand paging，直接page sharing即可。</p><h2 id="Copy-on-Write-COW"><a href="#Copy-on-Write-COW" class="headerlink" title="Copy-on-Write(COW)"></a>Copy-on-Write(COW)</h2><p>指定特定物理页面为copy-on-wirte(仅可修改页面)，当进程需要写入该页面时候(on write)，复制一份(copy)。</p><p>fork()的时候，新进程指向和原进程相同的物理页面，只不过部分页面指定为copy-on-write。当新进程需要写入操作，比如增加stack，heap等，由操作系统从frea pages pool寻找空闲页面，进行zero-fill-on-demand，用0填充。</p><p>fork()基于copy-on-write实现，而 vfork()则不使用copy-on-write技术，此方法下，父进程会暂停，子进程继承父进程的地址空间，子进程对地址空间的修改将会在父进程恢复后可见。vfork()常用于子进程须立即调用exec()的情况。在没有COW技术以前，fork()成本很高，需要完全复制新的地址空间，所以在fork()后使用exec丢弃原有地址空间，加载新地址空间是种浪费，所以设计了vfork()，和父进程共享地址空间，执行exec后使用新的地址空间，提高效率。当有COW技术后，vfork()+exec()和fork() + exec()效率几乎一样。<br><a href="https://techdifferences.com/difference-between-fork-and-vfork.html" target="_blank" rel="external">Difference Between fork() and vfork()</a><br><a href="https://stackoverflow.com/questions/4856255/the-difference-between-fork-vfork-exec-and-clone" target="_blank" rel="external">fork,vfork</a></p><h2 id="页面置换"><a href="#页面置换" class="headerlink" title="页面置换"></a>页面置换</h2><p>在使用demand paging的时候虽然增加了系统同时执行多道程序能力，然而会造成内存的过分配(over-allocating)。当page fault发生，然而此时没有空闲页面的时候，就需要页面置换了。</p><p>当没有空闲页面时，page fault后可以选择<br>    1.中断该程序<br>    2.置换一整个进程<br>    3.置换一个页面到置换分区 page replacement</p><h3 id="新的page-fault-服务程序"><a href="#新的page-fault-服务程序" class="headerlink" title="新的page fault 服务程序"></a>新的page fault 服务程序</h3><ol><li>Find the location of the desired page on the disk.</li><li>Find a free frame:<br> a. If there is a free frame, use it.<br> b. If there is no free frame, use a page-replacement algorithm to select a victim frame.<br> c. Write the victim frame to the disk; change the page and frame tables accordingly.</li><li>Read the desired page into the newly freed frame; change the page and<br>frame tables.</li><li>Continue the user process from where the page fault occurred.</li></ol><p>Note.<br>在没有空闲页面的时候，需要将1张待用的页面置换入内存，1张暂时不用的页面置换到置换分区。这样就降低了服务程序的效率。所以在页表上应当设置dirty bit(modify bit)，指明该页面自从从文件系统加载到内存有无修改。如果无修改，则无需将该页面置换到置换分区，直接将其用新的待加载页面覆盖即可，提升了效率。</p><h3 id="demand-paging-的2大核心算法"><a href="#demand-paging-的2大核心算法" class="headerlink" title="demand paging 的2大核心算法"></a>demand paging 的2大核心算法</h3><ol><li>frame-allocation algorithm 页面分配算法</li><li>page-replacement algorithm 页面置换算法</li></ol><p>page-replacement algorithm 物理页面分配算法主要解决，当加载一个进程的时候，到底给其分配多少物理内存页面的问题。</p><p>page-replacement algorithm 页面置换算法主要解决如何选择置换页面的问题。算法好的标准，低的page fault rate。</p><p><strong>置换算法分类：</strong></p><ul><li>局部置换算法，只置换本进程的物理页面。进程分配页面数不会改变。</li><li>全局置换算法，会跨进程置换物理页面。页面数会变化。缺点：无法控制自己的page fault rate。</li></ul><p>局部置换算法</p><ol><li>最优置换算法(OPT)：理想化，不可实现，在时间轴上向前看，将未来最久才会被访问的页面置换出去</li><li>最近最久未使用算法(LRU)：难实现，在时间轴上向后看，根据之前对也页面的访问统计进行置换，least recently used的页面会被置换</li><li>FIFO，根据加载到内存的顺序进行置换</li><li>clock，时钟置换算法，即在FIFO基础上，将页表内设置访问位，页面置换时，从前往后，只置换未访问页面，如果扫描中发现某页为已访问，则置为未访问状态，重新计时，并跳到下一页查找置换页。如同时钟一样扫描环形链表。又叫二次机会页面置换算法</li><li>LFU，最不常用页面置换算法</li><li>MFU，最常用页面置换算法，基于刚置入内存的页面访问频率很低的论据。</li></ol><h5 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h5><p>实现方法：</p><ol><li>counters计数器 在页表内设置记载访问时间的位，当内存访问时，将当前时钟寄存器内容复制到<br>page table记载位。这种方法需要搜索页表查找置换页，以及每次访问内存都得写内存。</li><li>Stack。越往上越最近使用。每次内存访问，将访问页置顶，需要置换时，将stack底部页面置换。</li></ol><p><img src="https://www.github.com/ChristopherKai/picsRepo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1517734351790.jpg" alt="stack实现的LRU置换算法"></p><p>Note.<br>Belady现象<br><img src="https://www.github.com/ChristopherKai/picsRepo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1517734814417.jpg" alt="belady现象"><br>随着物理内存增加，page fault rate增加。LRU，OPT等stack算法不会出现这种现象。 the set of pages in memory for n<br>frames is always a subset of the set of pages that would be in memory with n + 1 frames.即物理内存增大1页，原有的内存页面集合是增大后的内存页面集合的子集。</p><p><strong>额外引用位算法</strong></p><p>每次内存访问，引用位置1。页表内设置8比特的访问记录。每隔一段时间，访问记录右移一位，将引用位移到访问记录到最高位上，丢弃原有最低位。<br>这样00000000表示8个时间间隔内未访问该页，11111111表示每个时间间隔都访问了该页，11001100比起00110011更最近使用。如果将该记录解释为无符号整数，数字最小的将会是LRU页面，可以置换。</p><p>这些访问记录位的数量可以改变，如果变为0，也就是<strong>二次机会页面置换算法</strong>aka clock算法</p><p><strong>增强的clock算法</strong>考虑了修改位，这种算法减少了修改页的处理开销，尽量避免置换修改页。</p><h4 id="页面缓冲算法"><a href="#页面缓冲算法" class="headerlink" title="页面缓冲算法"></a>页面缓冲算法</h4><p>1.先加载页面到空闲物理内存，再置换victim物理页面到外存，并加入free frames pool，加速了进程重启速度。<br>2.周期性将修改过的页面写入置换分区，这样page fault适合，页面大概率时干净的，无需再次写入外存。<br>3.free-frame buffer ？？？<br>4.freaa-frame buffer pool:始终保留一定的空闲页面池，进程需要则分配，随后在进行页面置换，保持空闲页面池。</p><h4 id="应用与页面置换"><a href="#应用与页面置换" class="headerlink" title="应用与页面置换"></a>应用与页面置换</h4><p>有些情况下，应用通过虚拟内存访问数据的性能比没有的时候更差。比如数据库。<br>比如，数据仓库读取大量数据，然后计算后写入磁盘。LRU会保留新页面，然而应用更倾向于先使用旧的页面的数据进行计算。<br>因此，操作系统提供了raw disk和raw IO，绕过了文件系统。</p><p><strong>最小页面数</strong><br>进程最小页面数由系统架构(ISA)决定。具体来说，最小页面数由一条指令可能引用的页面数决定。如果不包含间接定址，只需要2个页面即可，1个指令页面，1个操作数页面。如果一条指令由于多次间接引用，需要访问不同页面，在到达执行步骤前未能将所需操作数取到，将会不断page fault，无法执行，最终需要分配不小于该条指令引用的页面数，即最小页面数。</p><h3 id="页面分配算法"><a href="#页面分配算法" class="headerlink" title="页面分配算法"></a>页面分配算法</h3><p>平均分配未考虑进程特性，会造成内存浪费。<br>按比例分配：按单个进程所需页面数与所有进程所需页面数的比例分配页面。需要大内存的进程分得更多页面。</p><p><strong>NUMA非均匀内存访问</strong><br>由于主板，cpu，内存的布局结构问题，cpu访问不同的内存位置，访问时间会不同。<br>分配算法的修改思路：随着调度器将进程调度到某个cpu上，对应地分配内存时，应将内存分配到和cpu同一块system board的内存部分上。</p><p><strong>Thrashing</strong><br>由于内存不足，一个进程的换页时间大于其执行时间。<br><img src="https://www.github.com/ChristopherKai/picsRepo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1517845412780.jpg" alt="Thranshing"></p><p>原因：一个进程内存不够page fault的时候，使用<em>全局置换算法</em>，将其他进程的页面置换到外存，然而置换出去的页面也是对应进程需要的。被置换页面的进程由于所需页面被置换，page fault继续倾吞其他进程的页面，最终导致所有进程互相倾吞对方的内存页面，不断的页面置换，进程全部暂停，处于等待磁盘IO的状态，CPU误以为利用率低，继续产生进程，提升多道程序能力，加剧这种现象，事实是CPU利用率更低。</p><p>解决办法：先考虑使用局部置换算法，这样，一个进程thrash了，无法窃取其他进程内存，无法造成其他进程的thrash。这样保证其他进程不会被影响。但是该进程处于始终等待paging device的状态，page fault的服务时间增加，影响了别的进程的EAT（等效访问时间）。想要彻底解决该问题，就需要保证分配给进程足够的页面数。</p><p>如何确定进程所需的页面数：<br>1.工作集策略。此方法定义了进程的局部性模型。局部性模型指进程运行时，从一个部分运行到另外一个部分。当不满足当前局部性时，会一直page fault，直到所有所需页面加载完毕，在转移局部性时，再次page fault，直到再次满足局部性。</p><p><strong>工作集模型</strong><br>工作集窗口：delta，最近的delta次页面访问<br>工作集：最近的delta次页面访问的页面集合，可以近似进程的局部性</p><p>关键：确定delta的大小，使得工作集体现进程的局部性。</p><p><strong>工作集置换算法</strong></p><p>假定delta为工作集窗口，delta次访问过页面即为工作集，在每次访问的时候，换出不在工作集页面，缺页则直接置入页面。</p><p>思想，每次访存剔除不在工作集页面，缺页则将页面置入。</p><p><strong>缺页率置换算法</strong></p><p>缺页率：缺页次数/访存次数，或者缺页时间间隔的倒数。</p><p>两次缺页间隔 &gt; 某一阈值 ，置换这两次间隔内未被引用的页面。<br>两次缺页间隔 &lt;= 某一阈值，将所缺页面加入常驻集。</p><p>思想：在缺页时根据缺页时间间隔改变常驻集以适应工作集。</p><p><strong>Memory-mapped Files</strong></p><p>//TODO</p><p><strong>Memory-mapped IO</strong></p><p>//TODO</p><p><strong>内核内存分配</strong></p><p>为了避免页式内存管理造成的碎片，以及特定硬件需要连续内存，内核内存分配使用连续分配算法。</p><pre><code>1.伙伴系统内存分配 Buddy system2.Slab内存分配，Slub，Slob内存分配</code></pre><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a><strong><strong>其他</strong></strong></h3><p><strong>预先调页 prepaging</strong></p><p>避免纯粹调页下，进程启动时的大量page faults。在暂停进程时，讲进程的工作集记录，再次启动时，先将工作集调入内存。</p><p><strong>页面大小 page size</strong></p><p>//</p><p><strong>TLR reach</strong></p><p>//</p><p><strong>反置页表与请求调页</strong></p><p>//</p><p><strong>程序结构</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i, j;</span><br><span class="line"><span class="keyword">int</span>[<span class="number">128</span>][<span class="number">128</span>] data;</span><br><span class="line"><span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">128</span>; i++)</span><br><span class="line"><span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; <span class="number">128</span>; j++)</span><br><span class="line">data[i][j] = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><p>虽然虚拟内存对程序透明，但是应当尽量提升程序的局部性，减少page faults。</p><p><strong>I/O Interlock and Page Locking</strong></p><p>页面锁为了防止出现以下情况：<br>一个进程请求IO，等待IO数据加载到内存缓冲页面。CPU调度到了其他进程。其他进程发生page fault，而且使用全局置换算法，置换了等待进程的缓冲页面。等到IO请求完成时，数据覆盖了该进程。</p><p>解决方案：<br>1.避免将IO写入用户内存。IO只发生在内核内存和IO设备间。  （X 复制开销太大）<br>2.在内存页面设置lock位，在IO期间，lock位置位。页面置换算法则会不去置换锁定(lock)的页面。</p><p>此外，内核常将自身内存锁定。某些应用程序，如数据库对自身内存使用情况更为了解，会将内存锁定，避免置换。操作系统会提供相关syscall。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">POSIX</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/mman.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mlock</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munlock</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *addr, <span class="keyword">size_t</span> len)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mlockall</span><span class="params">(<span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munlockall</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt; mlock() <span class="function"><span class="keyword">and</span> <span class="title">munlock</span><span class="params">()</span> <span class="title">mlock</span><span class="params">()</span> locks pages in the address range</span></span><br><span class="line">&gt; starting at addr and continuing  for  len  bytes. All pages that</span><br><span class="line">&gt; contain a part of the specified address range are guaranteed to be</span><br><span class="line">&gt; resident in RAM when the call returns successfully; the pages are</span><br><span class="line">&gt; guaranteed to stay in  RAM  until later unlocked.</span><br><span class="line">&gt; </span><br><span class="line">&gt; munlock()  unlocks  pages  in  the  address  range starting at addr</span><br><span class="line">&gt; <span class="keyword">and</span> continuing <span class="keyword">for</span> len bytes.  After <span class="keyword">this</span> call, all pages that contain</span><br><span class="line">&gt; a part of the specified memory  range  can be moved to external swap</span><br><span class="line">&gt; space again by the kernel.</span><br><span class="line"></span><br><span class="line">WIN</span><br><span class="line"><span class="function">BOOL WINAPI <span class="title">VirtualLock</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ LPVOID lpAddress,</span></span></span><br><span class="line"><span class="function"><span class="params">  _In_ SIZE_T dwSize</span></span></span><br><span class="line"><span class="function"><span class="params">)</span></span>;</span><br></pre></td></tr></table></figure><p>内存页面的位：<br>1.reference bit 记录一段时间内的页面访问情况，统计工作集，用于页面置换算法。<br>2.modify bit 记录页面自从从外存加载到内存有无修改，若无，则在页面置换的时候无需换出，直接覆盖。<br>2.modify bit 记录页面自从从外存加载到内存有无修改，若无，则在页面置换的时候无需换出，直接覆盖。<br>3.lock bit 防止置换算法将页面换出。<br>4.presenece bit 存在位，是否存在对应frame，触发page fault，继而请求调页。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;虚拟内存&quot;&gt;&lt;a href=&quot;#虚拟内存&quot; class=&quot;headerlink&quot; title=&quot;虚拟内存&quot;&gt;&lt;/a&gt;虚拟内存&lt;/h1&gt;&lt;h3 id=&quot;虚拟内存解决的问题：&quot;&gt;&lt;a href=&quot;#虚拟内存解决的问题：&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="-操作系统 -笔记" scheme="http://kaisblog.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>编译原理简述</title>
    <link href="http://kaisblog.cn/2018/05/20/%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E7%AE%80%E8%BF%B0/"/>
    <id>http://kaisblog.cn/2018/05/20/编译原理简述/</id>
    <published>2018-05-20T01:45:49.936Z</published>
    <updated>2018-05-20T01:45:49.937Z</updated>
    
    <content type="html"><![CDATA[<h1 id="编译器的三个阶段："><a href="#编译器的三个阶段：" class="headerlink" title="编译器的三个阶段："></a>编译器的三个阶段：</h1><pre><code>1.Parsing 对源代码解析成为源语言的AST2.Tranformation 将源语言AST转为目标语言AST3.Code Generation 从目标语言AST生成目标语言代码</code></pre><p>总结：<br><strong>Source Code</strong> </p><p>—-tokenizer———&gt; </p><p><strong>tokens</strong></p><p>—-parser————&gt;  </p><p><strong>source code AST</strong></p><p>—–transformer——&gt; </p><p><strong>taget language AST</strong> </p><p>—Code generator—–&gt;  </p><p><strong>Target Code</strong></p><h2 id="Parsing"><a href="#Parsing" class="headerlink" title="Parsing"></a>Parsing</h2><p>分为两个阶段：</p><ol><li>Lexical Analysis</li><li>Syntax Analysis</li></ol><h3 id="Lexical-Analysis"><a href="#Lexical-Analysis" class="headerlink" title="Lexical Analysis"></a>Lexical Analysis</h3><p>将源代码解析为token数组，如标签label，符号+-*/，数字等。</p><h3 id="Syntax-Analysis"><a href="#Syntax-Analysis" class="headerlink" title="Syntax Analysis"></a>Syntax Analysis</h3><p>将这个token数组重新组合，形成一个能够表示其内在联系的数据结构，叫做AST(Abstract Syntax Tree)。</p><h2 id="Transforming"><a href="#Transforming" class="headerlink" title="Transforming"></a>Transforming</h2><p>Lisp：<code>(add 2 (substract 4 2))</code><br>C：<code>add(2, substract(4,2))</code><br>从语言Lisp到类C语言。<br>Lisp一上来就是Call表达式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">* ----------------------------------------------------------------------------</span><br><span class="line"> *   &#123;                                |   &#123;</span><br><span class="line"> *     type: <span class="string">'Program'</span>,               |     type: <span class="string">'Program'</span>,</span><br><span class="line"> *     body: [&#123;                       |     body: [&#123;</span><br><span class="line"> *       type: <span class="string">'CallExpression'</span>,      |       type: <span class="string">'ExpressionStatement'</span>,</span><br><span class="line"> *       name: <span class="string">'add'</span>,                 |       expression: &#123;</span><br><span class="line"> *       params: [&#123;                   |         type: <span class="string">'CallExpression'</span>,</span><br><span class="line"> *         type: <span class="string">'NumberLiteral'</span>,     |         callee: &#123;</span><br><span class="line"> *         value: <span class="string">'2'</span>                 |           type: <span class="string">'Identifier'</span>,</span><br><span class="line"> *       &#125;, &#123;                         |           name: <span class="string">'add'</span></span><br><span class="line"> *         type: <span class="string">'CallExpression'</span>,    |         &#125;,</span><br><span class="line"> *         name: <span class="string">'subtract'</span>,          |         <span class="built_in">arguments</span>: [&#123;</span><br><span class="line"> *         params: [&#123;                 |           type: <span class="string">'NumberLiteral'</span>,</span><br><span class="line"> *           type: <span class="string">'NumberLiteral'</span>,   |           value: <span class="string">'2'</span></span><br><span class="line"> *           value: <span class="string">'4'</span>               |         &#125;, &#123;</span><br><span class="line"> *         &#125;, &#123;                       |           type: <span class="string">'CallExpression'</span>,</span><br><span class="line"> *           type: <span class="string">'NumberLiteral'</span>,   |           callee: &#123;</span><br><span class="line"> *           value: <span class="string">'2'</span>               |             type: <span class="string">'Identifier'</span>,</span><br><span class="line"> *         &#125;]                         |             name: <span class="string">'subtract'</span></span><br><span class="line"> *       &#125;]                           |           &#125;,</span><br><span class="line"> *     &#125;]                             |           <span class="built_in">arguments</span>: [&#123;</span><br><span class="line"> *   &#125;                                |             type: <span class="string">'NumberLiteral'</span>,</span><br><span class="line"> *                                    |             value: <span class="string">'4'</span></span><br><span class="line"> * ---------------------------------- |           &#125;, &#123;</span><br><span class="line"> *                                    |             type: <span class="string">'NumberLiteral'</span>,</span><br><span class="line"> *                                    |             value: <span class="string">'2'</span></span><br><span class="line"> *                                    |           &#125;]</span><br><span class="line"> *  (sorry the other one is longer.)  |         &#125;</span><br><span class="line"> *                                    |       &#125;</span><br><span class="line"> *                                    |     &#125;]</span><br><span class="line"> *                                    |   &#125;</span><br><span class="line"> * ----------------------------------------------------------------------------</span><br></pre></td></tr></table></figure><h3 id="Code-Generation"><a href="#Code-Generation" class="headerlink" title="Code Generation"></a>Code Generation</h3><p>从目标语言AST转为目标语言。</p><p>参考自youtube视频<a href="https://www.youtube.com/watch?v=Tar4WgAfMr4" target="_blank" rel="external">How to Build a Compiler by James Kyle</a><br>参考2：<a href="https://github.com/jamiebuilds/the-super-tiny-compiler/blob/master/the-super-tiny-compiler.js#L161" target="_blank" rel="external">超小编译器</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;编译器的三个阶段：&quot;&gt;&lt;a href=&quot;#编译器的三个阶段：&quot; class=&quot;headerlink&quot; title=&quot;编译器的三个阶段：&quot;&gt;&lt;/a&gt;编译器的三个阶段：&lt;/h1&gt;&lt;pre&gt;&lt;code&gt;1.Parsing 对源代码解析成为源语言的AST
2.Tranfo
      
    
    </summary>
    
    
      <category term="Note" scheme="http://kaisblog.cn/tags/Note/"/>
    
      <category term="Compiler" scheme="http://kaisblog.cn/tags/Compiler/"/>
    
  </entry>
  
  <entry>
    <title>线程</title>
    <link href="http://kaisblog.cn/2018/05/20/%E7%BA%BF%E7%A8%8B/"/>
    <id>http://kaisblog.cn/2018/05/20/线程/</id>
    <published>2018-05-20T01:45:49.935Z</published>
    <updated>2018-05-20T01:45:49.936Z</updated>
    
    <content type="html"><![CDATA[<pre><code>线程包括：1.线程号 2.寄存器集合 ，包含PC程序计数器3.Stack,包括User Stack和Kernel Stack4.私有存储，被运行时库或DLL使用</code></pre><p>后三项被称作Thread的Context</p><p>线程的好处：</p><pre><code>1.响应度。UI线程和费时的计算线程分开，提升响应度。2.资源共享。进程之间共享只能通过shared memeory或message passing。线程默认共享内存和资源。3.经济。线程的创建与上下文切换相比进程更快。4.拓展性（Scalability）。多线程在多核处理器下，可以充分利用处理器。</code></pre><p>//多核与多处理器的区别。多核可能在一个芯片上，多处理器则是多个独立的cpu。</p><p><strong>Parallelism vs Concurrency</strong><br>Parallel 表示一个系统可以<strong>同时</strong>运行多个任务。<br>Concurrent表示一个系统可以使多个任务都取得运作。</p><p>在SMP和多核之前，单处理器在进程之间使用快速上下文切换来提供一种parallel的假象。</p><p>并行编程的挑战：<br>    1.identify task。合理分割任务，使并行。<br>    2.balance。各个任务运算平衡。<br>    3.data splitting<br>    4.data dependency<br>    5.test and debug</p><p>//  AMDAHL’S LAW  ???</p><p>并行的分类：<br>1.数据并行。比如两个线程分别求和数组的两半。<br>2.任务并行。</p><h2 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h2><p><strong>多对一</strong></p><p>多个用户线程对应一个内核线程。当一个用户线程进行阻塞系统调用，对应内核线程阻塞，整个进程就会阻塞。缺点：无法利用多核系统实现并行。eg。Solaris的Green Threads.</p><p><strong>一对一</strong></p><p>一个用户线程对应一个内核线程。缺点：因为一对一，系统支持的线程数量会有限制。eg.Linux和windows</p><p><strong>多对多</strong></p><p>内核线程数小于等于用户线程数。优势：线程数无限制，充分利用多核。</p><h2 id="线程库"><a href="#线程库" class="headerlink" title="线程库"></a>线程库</h2><p>两种线程库：<br>1.纯粹在用户空间实现，无内核支持。调用库函数不会发生系统调用。<br>2.在内核空间实现，库的代码数据在内核存在。会发生系统调用。</p><p>三种主流线程库：POSIX Pthreads,Windows,Java。</p><p>Pthreads: 用户、内核<br>Windows：内核<br>Java:取决于宿主系统，在Windows用windows api，Linux/Unix 用Pthreads</p><p>windows ，linux下线程共享全局数据。然而在Java下，没有全局数据的概念，线程间共享数据需要额外的准备。</p><p>线程创建的两种模型：</p><p>1.异步。 创建后，并发执行。通常，数据共享比较少。<br>2.同步。 创建后，父线程等待子线程终止。</p><p>Note.<br>Pthread是POSIX 的一个线程行为标准，具体实现取决于系统设计者。比如Linux,MAC OS，Solaris。</p><p>创建线程</p><p>Linux</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Linux</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">int</span> sum; <span class="comment">/* this data is shared by the thread(s) */</span></span><br><span class="line"><span class="comment">// void func(void *)类型的函数指针</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">runner</span><span class="params">(<span class="keyword">void</span> *param)</span></span>; <span class="comment">/* threads call this function */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_t</span> tid; <span class="comment">/* the thread identifier */</span></span><br><span class="line">    <span class="keyword">pthread_attr_t</span> attr; <span class="comment">/* set of thread attributes */</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"usage: a.out &lt;integer value&gt;\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (atoi(argv[<span class="number">1</span>]) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"%d must be &gt;= 0\n"</span>,atoi(argv[<span class="number">1</span>]));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* get the default attributes */</span></span><br><span class="line">    pthread_attr_init(&amp;attr);</span><br><span class="line">    <span class="comment">/* create the thread */</span></span><br><span class="line">    pthread_create(&amp;tid,&amp;attr,runner,argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">/* wait for the thread to exit */</span></span><br><span class="line">    pthread_join(tid,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sum = %d\n"</span>,sum);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* The thread will begin control in this function */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">runner</span><span class="params">(<span class="keyword">void</span> *param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, upper = atoi(param);</span><br><span class="line">    sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt;= upper; i++)</span><br><span class="line">        sum += i;   </span><br><span class="line">    <span class="function">pthread <span class="title">exit</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Linux同时提供clone()系统调用创建线程。Linux常用Task来表述一个程序的控制流。当调用clone时附带共享内存等Flags时，等同于创建线程，当没有共享Flags时，等同于fork()创建线程。这样，各种程度的共享是可以实现的，</p><table><thead><tr><th>flag</th><th>意义</th></tr></thead><tbody><tr><td>CLONE_FS</td><td>共享文件系统信息</td></tr><tr><td>CLONE_VM</td><td>共享内存空间</td></tr><tr><td>CLONE_SIGHAND</td><td>共享信号handles</td></tr><tr><td>CLONE_FILES</td><td>共享打开的文件</td></tr></tbody></table><p>Windows</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">\\windows</span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;windows.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line">DWORD Sum; <span class="comment">/* data is shared by the thread(s) */</span></span><br><span class="line"><span class="comment">/* the thread runs in this separate function */</span></span><br><span class="line"><span class="function">DWORD WINAPI <span class="title">Summation</span><span class="params">(LPVOID Param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD Upper = *(DWORD*)Param;</span><br><span class="line">    <span class="keyword">for</span> (DWORD i = <span class="number">0</span>; i &lt;= Upper; i++)</span><br><span class="line">        Sum += i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    DWORD ThreadId;</span><br><span class="line">    HANDLE ThreadHandle;</span><br><span class="line">    <span class="keyword">int</span> Param;</span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"An integer parameter is required\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Param = atoi(argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="keyword">if</span> (Param &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"An integer &gt;= 0 is required\n"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* create the thread */</span></span><br><span class="line">ThreadHandle = CreateThread(</span><br><span class="line">                            <span class="literal">NULL</span>, <span class="comment">/* default security attributes */</span></span><br><span class="line">                            <span class="number">0</span>, <span class="comment">/* default stack size */</span></span><br><span class="line">                            Summation, <span class="comment">/* thread function */</span></span><br><span class="line">                            &amp;Param, <span class="comment">/* parameter to thread function */</span></span><br><span class="line">                            <span class="number">0</span>, <span class="comment">/* default creation flags */</span></span><br><span class="line">                            &amp;ThreadId); <span class="comment">/* returns the thread identifier */</span></span><br><span class="line"><span class="keyword">if</span> (ThreadHandle != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="comment">/* now wait for the thread to finish */</span></span><br><span class="line">    WaitForSingleObject(ThreadHandle,INFINITE);</span><br><span class="line">    <span class="comment">/* close the thread handle */</span></span><br><span class="line">    CloseHandle(ThreadHandle);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"sum = %d\n"</span>,Sum);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JAVA</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JAVA</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sum</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> sum;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getSum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSum</span><span class="params">(<span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.sum = sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Summation</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> upper;</span><br><span class="line">    <span class="keyword">private</span> Sum sumValue;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Summation</span><span class="params">(<span class="keyword">int</span> upper, Sum sumValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.upper = upper;</span><br><span class="line">        <span class="keyword">this</span>.sumValue = sumValue;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= upper; i++)</span><br><span class="line">            sum += i;</span><br><span class="line">        sumValue.setSum(sum);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Driver</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Integer.parseInt(args[<span class="number">0</span>]) &lt; <span class="number">0</span>)</span><br><span class="line">                System.err.println(args[<span class="number">0</span>] + <span class="string">" must be &gt;= 0."</span>);</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                Sum sumObject = <span class="keyword">new</span> Sum();</span><br><span class="line">                <span class="keyword">int</span> upper = Integer.parseInt(args[<span class="number">0</span>]);</span><br><span class="line">                Thread thrd = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Summation(upper, sumObject));</span><br><span class="line">                thrd.start();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    thrd.join();</span><br><span class="line">                    System.out.println</span><br><span class="line">                    (<span class="string">"The sum of "</span>+upper+<span class="string">" is "</span>+sumObject.getSum());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123; &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.err.println(<span class="string">"Usage: Summation &lt;integer value&gt;"</span>); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Implicit-Threading"><a href="#Implicit-Threading" class="headerlink" title="Implicit Threading"></a>Implicit Threading</h3><p>Implicit Threading:将进程的创建与管理交给编译器与运行时库。</p><p>方法:<br>1.Thread Pools<br>2.OpenMP<br>3.GCD<br>4..</p><h4 id="线程池-Thread-Pools"><a href="#线程池-Thread-Pools" class="headerlink" title="线程池 Thread Pools"></a>线程池 Thread Pools</h4><p>理念：在进程创建时初始化一定数量的线程，并置于线程池。当需要线程，从线程池激活一个线程，并工作，等其完成则返回线程池等待新的工作。如果线程池没有空闲线程，则等待。</p><p>好处：<br>1.响应请求速度提升，已经创建好的线程比新创建线程速度快。<br>2.限制了线程数量，防止超过系统承受。</p><p>windows<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DWORD WINAPI <span class="title">PoolFunction</span><span class="params">(AVOID Param)</span> </span>&#123;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* this function runs as a separate thread.</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">QueueUserWorkItem(&amp;PoolFunction, <span class="literal">NULL</span>, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></p><h4 id="OpenMP"><a href="#OpenMP" class="headerlink" title="OpenMP"></a>OpenMP</h4><p>OpenMP是一套支持C/C++，FORTRAN 并行编程的编译器伪指令，api。<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;omp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">/* sequential code */</span></span><br><span class="line">    <span class="meta">#<span class="meta-keyword">pragma</span> omp parallel</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"I am a parallel region."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/* sequential code */</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="Grand-Central-Dispatch"><a href="#Grand-Central-Dispatch" class="headerlink" title="Grand Central Dispatch"></a>Grand Central Dispatch</h4><p>MAC OS X与iOS。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ˆ&#123; <span class="built_in">printf</span>(<span class="string">"I am a block"</span>); &#125;</span><br></pre></td></tr></table></figure><p>Note.<br>POSIX是一套api标准，遵循此标准的操作系统为POSIX操作系统，The Portable Operating System Interface。</p><p>链接：<br>[POSIX api1][1]<br>[POSIX api2][2]<br>[标准C库][3]</p><h3 id="线程与进程复制"><a href="#线程与进程复制" class="headerlink" title="线程与进程复制"></a>线程与进程复制</h3><p>fork()在多线程下，有可能复制所有线程，或只复制调用fork()的线程。如果fork()后会exec()则调用后者，即只复制单一线程比较经济。否则，前者更为适用。</p><p>exec()在多线程下，直接替换整个进程，包括所有线程。</p><h3 id="信号处理"><a href="#信号处理" class="headerlink" title="信号处理"></a>信号处理</h3><p>Unix下，信号用于通知进程特定事件发生了。取决于信号源或信号发送原因，信号是同步或者异步的。</p><p>信号必须被处理。</p><p>同步信号:异常内存访问，除0错误等。</p><p>异步信号：由进程外部事件产生，比如ctrl +C.</p><p>信号到底应该发送给特定线程还是所有线程，取决于信号种类。</p><p><code>kill(pid_t pid, int signal)</code>Unix发送信号<code>pthread_kill(pthread_t tid, int signal)</code></p><p>Windows用asynchronous procedure calls (APC)模拟异步信号。</p><h3 id="线程取消"><a href="#线程取消" class="headerlink" title="线程取消"></a>线程取消</h3><p>目标线程(target thread):要被取消的线程</p><p>取消方式：<br>1.异步：一个线程立即取消目标线程<br>2.延期的(deferred)：目标线程周期性检查是否应该终结，给其一个可以稍晚取消的机会。</p><p>线程取消的难点在于目标线程存在与其他线程共享的资源</p><p>POSIX<code>pthread_create(&amp;tid, 0, worker, NULL);</code>只是发起取消请求，具体如何取消，取决于线程的handle。</p><table><thead><tr><th>Mode</th><th>State</th><th>Type</th></tr></thead><tbody><tr><td>Off</td><td>Disabled</td><td>-</td></tr><tr><td>异步</td><td>Enabled</td><td>异步</td></tr><tr><td>延期</td><td>Enabled</td><td>延期</td></tr></tbody></table><p>默认类型为“延期”，到达取消点(cancellation point)的时候，会被取消。<br><code>pthread_testcancel()</code>用于测试取消点。在取消之前cleanup handler函数会被调用以释放分配的资源。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line"><span class="comment">/* do some work for awhile */</span></span><br><span class="line"><span class="comment">/* ... */</span></span><br><span class="line"><span class="comment">/* check if there is a cancellation request */</span></span><br><span class="line">pthread_testcancel();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线程本地存储"><a href="#线程本地存储" class="headerlink" title="线程本地存储"></a>线程本地存储</h3><p>在特定情况下，线程需要私有的数据，即Thread Local Storage.TLS不同于局部变量，后者只函数内存在。TLS有点类似static变量，但是TLS对线程唯一。</p><h3 id="Scheduler-Activations"><a href="#Scheduler-Activations" class="headerlink" title="Scheduler Activations"></a>Scheduler Activations</h3><p>//TODO ????</p><h3 id="LWP-轻权进程"><a href="#LWP-轻权进程" class="headerlink" title="LWP 轻权进程"></a>LWP 轻权进程</h3><p>//TODO</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;线程包括：
1.线程号 
2.寄存器集合 ，包含PC程序计数器
3.Stack,包括User Stack和Kernel Stack
4.私有存储，被运行时库或DLL使用
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;后三项被称作Thread的Context&lt;/p&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="Note" scheme="http://kaisblog.cn/tags/Note/"/>
    
      <category term="Operating System" scheme="http://kaisblog.cn/tags/Operating-System/"/>
    
      <category term="操作系统" scheme="http://kaisblog.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>用Python写一个超简单的静态网站服务器</title>
    <link href="http://kaisblog.cn/2018/05/20/%E7%94%A8Python%E5%86%99%E4%B8%80%E4%B8%AA%E8%B6%85%E7%AE%80%E5%8D%95%E7%9A%84%E9%9D%99%E6%80%81%E7%BD%91%E7%AB%99%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://kaisblog.cn/2018/05/20/用Python写一个超简单的静态网站服务器/</id>
    <published>2018-05-20T01:45:49.934Z</published>
    <updated>2018-05-20T01:45:49.935Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket, os,os.path <span class="keyword">as</span> path</span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"></span><br><span class="line">HOST = <span class="string">''</span></span><br><span class="line">PORT = <span class="number">8000</span></span><br><span class="line"><span class="comment"># 把hexo的public文件夹放在同目录下即可</span></span><br><span class="line">ROOT_DIR = <span class="string">r'public'</span></span><br><span class="line"><span class="comment"># 因为很简单。。所以http 头部除了关键部分，都写死了。。</span></span><br><span class="line"></span><br><span class="line">res_str = <span class="string">'''HTTP/1.1 200 OK\r</span></span><br><span class="line"><span class="string">Date: Sat, 10 Feb 2018 12:38:32 GMT\r</span></span><br><span class="line"><span class="string">Server: MySimpleServer\r</span></span><br><span class="line"><span class="string">Last-Modified: Tue, 12 Jan 2010 13:48:00 GMT\r</span></span><br><span class="line"><span class="string">Accept-Ranges: bytes\r</span></span><br><span class="line"><span class="string">Cache-Control: max-age=86400\r</span></span><br><span class="line"><span class="string">Expires: Sun, 11 Feb 2018 12:38:32 GMT\r</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">http_300_res_str = <span class="string">'''HTTP/1.1 404 File Not Found\r</span></span><br><span class="line"><span class="string">Date: Sat, 10 Feb 2018 12:38:32 GMT\r</span></span><br><span class="line"><span class="string">Server: MySimpleServer\r</span></span><br><span class="line"><span class="string">Last-Modified: Tue, 12 Jan 2010 13:48:00 GMT\r</span></span><br><span class="line"><span class="string">Accept-Ranges: bytes\r</span></span><br><span class="line"><span class="string">Cache-Control: max-age=86400\r</span></span><br><span class="line"><span class="string">Expires: Sun, 11 Feb 2018 12:38:32 GMT\r</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">ext_to_mime = &#123;</span><br><span class="line">    <span class="string">'.html'</span>: <span class="string">'text/html'</span>,</span><br><span class="line">    <span class="string">'.js'</span>: <span class="string">'text/javascript'</span>,</span><br><span class="line">    <span class="string">'.css'</span>: <span class="string">'text/css'</span>,</span><br><span class="line">    <span class="string">'.jpg'</span>: <span class="string">'image/jpg'</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">makeResponse</span><span class="params">(req_path)</span>:</span></span><br><span class="line">    req_path = urllib.parse.unquote(req_path)</span><br><span class="line">    <span class="comment">#请求目录则返回目录下的index.html，请求文件则返回文件</span></span><br><span class="line">    req_path = req_path + <span class="string">'index.html'</span> <span class="keyword">if</span> req_path.endswith(<span class="string">r'/'</span>) <span class="keyword">else</span> req_path</span><br><span class="line">    req_f_path = ROOT_DIR + req_path</span><br><span class="line">    <span class="comment"># print(req_f_path)</span></span><br><span class="line">    res_bytes = bytearray()</span><br><span class="line">    res_bytes.extend(bytes(res_str, <span class="string">'utf-8'</span>))</span><br><span class="line">    <span class="comment"># File Not Found 返回404</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(req_f_path):</span><br><span class="line">        res_bytes.extend(bytes(http_300_res_str, <span class="string">'utf-8'</span>))</span><br><span class="line">        <span class="keyword">return</span> res_bytes</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> open(req_f_path,<span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">        stat = os.stat(req_f_path)</span><br><span class="line">        file_size = stat.st_size</span><br><span class="line">        extension = path.splitext(req_f_path)[<span class="number">1</span>]</span><br><span class="line">        mime = ext_to_mime[extension]</span><br><span class="line">        append_headers = <span class="string">"Content-Length: &#123;0&#125;\r\nContent-Type: &#123;1&#125;\r\n\r\n"</span>.format(file_size,mime)</span><br><span class="line">        res_bytes.extend(bytes(append_headers, <span class="string">'utf-8'</span>))</span><br><span class="line">        file_content = f.read()</span><br><span class="line">        res_bytes.extend(file_content)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> res_bytes</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">with</span> socket.socket(socket.AF_INET, socket.SOCK_STREAM) <span class="keyword">as</span> s:</span><br><span class="line">        s.bind((HOST, PORT))</span><br><span class="line">        s.listen(<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            conn, address = s.accept()</span><br><span class="line">            <span class="keyword">with</span> conn:</span><br><span class="line">                print(<span class="string">'Connected by'</span>, address)</span><br><span class="line">                data = bytearray()</span><br><span class="line">                <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">                    recvd = conn.recv(<span class="number">10240</span>)</span><br><span class="line">                    data.extend(recvd)</span><br><span class="line">                    <span class="keyword">if</span> <span class="keyword">not</span> recvd: <span class="keyword">break</span></span><br><span class="line">                    req = str(data)</span><br><span class="line">                    headers = req.split(<span class="string">r'\r\n'</span>)</span><br><span class="line">                    start_line = headers[<span class="number">0</span>]</span><br><span class="line">                    req_path = start_line.split()[<span class="number">1</span>]</span><br><span class="line">                    res = makeResponse(req_path)</span><br><span class="line">                    conn.sendall(res)</span><br><span class="line">                    data = bytearray()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span clas
      
    
    </summary>
    
    
      <category term="Note" scheme="http://kaisblog.cn/tags/Note/"/>
    
      <category term="python" scheme="http://kaisblog.cn/tags/python/"/>
    
      <category term="http" scheme="http://kaisblog.cn/tags/http/"/>
    
  </entry>
  
  <entry>
    <title>在chrome内打开微信公众号的方法</title>
    <link href="http://kaisblog.cn/2018/05/20/%E5%9C%A8chrome%E5%86%85%E6%89%93%E5%BC%80%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://kaisblog.cn/2018/05/20/在chrome内打开微信公众号的方法/</id>
    <published>2018-05-20T01:45:49.933Z</published>
    <updated>2018-05-20T01:45:49.933Z</updated>
    
    <content type="html"><![CDATA[<p>问题：“请在微信客户端打开链接”。<br><img src="https://www.github.com/ChristopherKai/picsRepo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1526563881042.jpg" alt="“请在微信客户端打开链接”"></p><p>不要问为啥把好好能在微信打开的网页放在chrome里面打开，因为你能debug卡断点，看代码啊！</p><p>首先，需要明白，打开一个第三方网页的时候到底发生了什么。当你在微信内打开一个公众号网页，其会访问公众号的第三方网站如<code>https://appsth.h5.xiaoeknow.com/content_page/example</code>，如果公众号检测到请求的User-Agent,Cookie,Referer不对，则会返回HTTP 302，将浏览器重定向到响应头部的Location字段。所以，要避免这一重定向，就将要发送的HTTP头部使用chrome插件修改。</p><p><img src="https://www.github.com/ChristopherKai/picsRepo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1526563736658.jpg" alt="windows微信客户端访问公众号的http请求头部"></p><p>安装chrome插件：<a href="https://chrome.google.com/webstore/detail/modify-headers-for-google/innpjfdalfhpcoinfnehdnbkglpmogdi?hl=en-US" target="_blank" rel="external">Modify Headers for Google Chrome</a></p><p>修改浏览器http头部：<br>最重要的User-Agent：Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36 MicroMessenger/6.5.2.501 NetType/WIFI WindowsWechat QBCore/3.43.691.400 QQBrowser/9.0.2524.400<br>次重要的Cookie：按具体网页而定，经过抓包分析(推荐<a href="http://blog.devtang.com/2015/11/14/charles-introduction/" target="_blank" rel="external">charles</a>)<br><img src="https://www.github.com/ChristopherKai/picsRepo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1526565326711.jpg" alt="修改http头部"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;问题：“请在微信客户端打开链接”。&lt;br&gt;&lt;img src=&quot;https://www.github.com/ChristopherKai/picsRepo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1526563881042.jpg&quot; a
      
    
    </summary>
    
    
      <category term="Note" scheme="http://kaisblog.cn/tags/Note/"/>
    
      <category term="web" scheme="http://kaisblog.cn/tags/web/"/>
    
      <category term="wechat" scheme="http://kaisblog.cn/tags/wechat/"/>
    
  </entry>
  
  <entry>
    <title>内存管理</title>
    <link href="http://kaisblog.cn/2018/05/20/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"/>
    <id>http://kaisblog.cn/2018/05/20/内存管理/</id>
    <published>2018-05-20T01:45:49.932Z</published>
    <updated>2018-05-20T01:45:49.933Z</updated>
    
    <content type="html"><![CDATA[<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><h2 id="连续内存管理"><a href="#连续内存管理" class="headerlink" title="连续内存管理"></a>连续内存管理</h2><ul><li>固定大小：MFT</li><li><p>可变大小：MVT</p></li><li><p>策略： </p><p><strong>First fit</strong>. Allocate the first hole that is big enough. Searching can start either at the beginning of the set of holes or at the location where the previous first-fit search ended. We can stop searching as soon as we find a free hole that is large enough. </p><p><strong>Best fit</strong>. Allocate the smallest hole that is big enough. We must search the entire list, unless the list is ordered by size. This strategy produces the smallest leftover hole.</p><p><strong>Worst fit</strong>. Allocate the largest hole. Again, we must search the entire list, unless it is sorted by size. This strategy produces the largest leftover hole, which may be more useful than the smaller leftover hole from a best-fit approach.</p><p><em>评价</em>： both first fit and best fit are better than worst fit in terms of decreasing time and storage utilization. Neither first fit nor best fit is clearly better than the other in terms of storage utilization, but first fit is generally faster.</p><p>三种策略都会产生碎片    内外相对于操作系统分配给进程的空间而言。</p><p>1.外部碎片：系统分配的空间之间无法再分配给进程的内存空间   [processA 4k,,between 2KprocessB 5K]  wasted 2k,allocate minimal size 4K<br>2.内部碎片：分配给进程的空间，但是比进程请求大小大的内存空间  [Allocated  10K,  process requeste 4k]    wasted 6k</p></li></ul><p>对待碎片的办法：Compaction，移动进程空间合并空闲内存</p><p>compaction的可行性：Compaction is not always possible, however. If relocation is static and is done at assembly or load time, compaction cannot be done. It is possible only if relocation is dynamic and is done at execution time. If addresses are relocated dynamically, relocation requires only moving the program and data and then changing the base register to reflect the new base address.</p><p>compaction的实现方法：</p><pre><code>1.所有进程移动到内存一端2.使进程逻辑地址不连续：    2.1.分段segmentation    2.2.分页paging</code></pre><h2 id="非连续内存分配"><a href="#非连续内存分配" class="headerlink" title="非连续内存分配"></a>非连续内存分配</h2><h3 id="分段Segmentation："><a href="#分段Segmentation：" class="headerlink" title="分段Segmentation："></a>分段Segmentation：</h3><p>原理：程序员视角下，程序分为不同的段，如代码段，数据段，堆。。为了支持这种视角，内存分段。逻辑地址变为<segmentation number,offset=""></segmentation></p><p>C编译器会创建的段：<br>    1.The code</p><pre><code>2. Global variables3. The heap, from which memory is allocated4. The stacks used by each thread5. The standard C libraryLibraries that are linked in during compile time might be assigned separate segments. The loader would take all these segments and assign them segment numbers.加载器会给各个段分配段号。</code></pre><h3 id="分页Paging："><a href="#分页Paging：" class="headerlink" title="分页Paging："></a>分页Paging：</h3><h4 id="优势："><a href="#优势：" class="headerlink" title="优势："></a>优势：</h4><p>可以避免外部碎片，避免compaction。而且解决了将可变大小内存块备份到back storage的问题，可以使可使用的物理地址范围大于cpu地址指针范围。</p><p>Note.<br>由于进程内存要换swap到back storage上时，由于back storage速度低，同时同样存在碎片，back  storage的compaction就不可行。</p><h4 id="方法："><a href="#方法：" class="headerlink" title="方法："></a>方法：</h4><p>分割内存为固定大小，称作frames；同时分割逻辑内存为同样大小，称作pages。back storage同样分割为同样大小，或该大小的整数倍。将pages根据page table映射到frame上。逻辑地址前一部分作为page table的索引，后一部分作为frame内的偏移。PTBR和PTLR(page-table length register )，PTLR指明page table的长度</p><p>Terms：<br>page table：<br>逻辑地址物理地址转换表<br>frame table：<br>表示物理内存上的frames 是否可用的表</p><p>对进程context switch 的影响：The operating system maintains a copy of the page table for each process, just as it maintains a copy of the instruction counter and register contents.A pointer to the page table is stored with the other register values (like the instruction counter) in the process control block.<br>每个进程创建一张页表，页表指针和其他寄存器值一同储存在进程控制单元（ process control block）内。</p><h4 id="页表具体实现："><a href="#页表具体实现：" class="headerlink" title="页表具体实现："></a>页表具体实现：</h4><pre><code>1.  DEC PDP-11：用寄存器来实现页表的架构。2.  当代架构：PTBR，a page-table base register指向页表，context switch时候只需改变ptbr即可，减少开销。  </code></pre><p> 缺点：每次地址转换需要访问两次内存（内存取page number和访问物理地址）    </p><p> 解决方案：<br> 1.TLB，translation look-aside buffer，快表，逻辑地址page number作key，物理地址frame number作value的数组缓存，每次针对page number会与所有项目的key同时比较，所以快,有的会包含ASID信息，用于识别进程以及保护信息，如果没有ASIDs则context switch后，TLB会flush掉TLB以用新进程的page table.TLB的hit ratio 直接影响内存访问性能。</p><p> page table内容：<br> 1.frame number<br> 2.valid 或者invliad 是否存在对应的frame，可能存在一个page被置为vaid但是进程实际空间小于page size，造成内部碎片。</p><p> shared pages:<br> 可以将reentrant code跨进程共享。</p><h4 id="页表的结构分类"><a href="#页表的结构分类" class="headerlink" title="页表的结构分类:"></a>页表的结构分类:</h4><p> 1.hierarchical paging,多级页表aka forward-mapped page table     举例VAX<br> 2.hashed page tables,  变体clustered page tables（？） 举例<br> 3.inverted page tables.反置页表，页表项需包含ASIDs，变体哈希反置页表 ，如何解决共享内存的问题？？？？？</p><p> 分页具体实现：<br> 1.Oracle SPARC Solaris 64位，多级哈希页表，用户和内核相互独立的页表，每个页表项对应一片连续page，包含一个base和span number，指明page数目？？？？。。。。。。<br> 2.8086、8088支持分段，IA32支持分页分段</p><p> 具体<br> <strong><em>IA32：</em></strong><br> CPU –&gt; 逻辑地址  –&gt;分段单元 –&gt; 线性地址 –&gt;分页单元 –&gt;物理地址 —&gt;内存</p><p> 分段：</p><p> MMU 内存管理单元：分段单元，分页单元<br> 段大小可达4GB，每个进程段的数量16K，逻辑地址空间分为2部分，第一部分包含<code>! 2 **13</code>(8K)个段，对进程私有，第二部分 8K段，跨进程共享。第一部分信息在LDT，第二部分在GDT。每个表项8字节，包含基址base和段界限limit。逻辑地址为  (selector, offset)selector为16位，13位 段号，1位指明是LDT还是GDT，2位保护。共有6个段寄存器，允许一个进程同时定址6个段。同时有6个8字节的描述符寄存器，保存gdt，ldt描述符。offset偏移加上selector指向的描述符基址，形成32位线性地址。</p><p> 分页：</p><p> 支持页大小4k或4M。对于4K使用2层分页机制,p1:10位，p2：10位，page offset：12位.p1:作为页目录page directory，cr3寄存器指向当前进程页目录页目录项包含Page_Size的flag表明是4kb还是4MB，如果为4MB，则p2和offset结合起来直接指向4MB的frame<br> 图例<br> <img src="https://www.github.com/ChristopherKai/picsRepo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/pic-1517647969601.png" alt="enter description here" title="pic-1517647969601"><br> PAE（page address extension）的引入：线性地址前两位作为page directory pointer table，<br> <img src="https://www.github.com/ChristopherKai/picsRepo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/pic-1517647969623.png" alt="enter description here" title="pic-1517647969623"></p><p> PAE允许访问的物理空间大于4GBPAE also increased the page-directory and page-table entries from 32 to 64 bits in size, which allowed the base address of page tables and page frames to extend from 20 to 24 bits. Combined with the 12-bit offset, adding PAE support to IA-32 increased the address space to 36 bits, which supports up to 64 GB of physical memory. It is important to note that operating system support is required to use PAE. Both Linux and Intel Mac OS X support PAE. However, 32-bit versions of Windows desktop operating systems still provide support for only 4 GB of physical memory, even if PAE is enabled.windows 又被黑了。</p><p><strong><em>x86-64</em></strong></p><p><strong><em>历史</em></strong></p><p>曾经研发IA64（后来的Itanium），但是未被广泛接受。同时AMD在IA32上拓展，研发了x86-64，结果intel学习了AMD的结构。</p><p>具体</p><p>48位的虚拟地址，页大小4kb，2MB，1GB，使用了4级页表，加上PAE的支持，空间达到52比特<br><img src="https://www.github.com/ChristopherKai/picsRepo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/pic-1517647969601.png" alt="enter description here" title="pic-1517647969601"></p><p>FROM BOOK OS Concepts:</p><p>Terminology:<br>1.input queue:The processes on the disk that are waiting to be brought into memory for execution form the input queue.    ready queue:The system maintains a ready queue consisting of all processes whose memory images are on the backing store or in memory and are ready to run.<br>2.逻辑地址：cpu生成的地址<br>3.物理地址：内存看到的地址，载入到内存地址寄存器的地址<br>4.虚拟地址：The compile-time and load-time address-binding methods generate identical logical and physical addresses。However, the execution-time address- binding scheme results in differing logical and physical addresses. In this case, we usually refer to the logical address as a virtual address.<br>5.MMU（memory-management unit）：实现逻辑地址到物理地址的转换<br>6.动态加载   只加载自用模块，只需os提供加载库<br>7.动态链接  加载跨进程共享库，需要os协助，因为需要跨进程内存访问<br>8.Swap ，移动操作系统不支持    {        Modified versions of swapping, however, are found on many systems, including UNIX, Linux, and Windows. In one common variation, swapping is normally disabled but will start if the amount of free memory (unused memory available for the operating system or processes to use) falls below a threshold amount. Swapping is halted when the amount of free memory increases. Another variation involves swapping portions of processes—rather than entire processes—to decrease swap time. Typically, these modified forms of swapping work in conjunction with virtual memory, which we cover in Chapter 9.    }<br>9.double buffering<br>10.50-percent rule.：Statistical analysis of first fit, for instance, reveals that, even with some optimization, given N allocated blocks, another 0.5 N blocks will be lost to fragmentation. That is, one-third of memory may be unusable! This property is known as the 50-percent rule.<br>11.wired down：TLB中无法被替换的项目，比如kernel地址<br>12.reentrant code:non-self-modifying code:,it never changes during execution.</p><p>地址绑定：将程序内指令与物理地址绑定绑定可以发生在：<br>1.编译时（编译时确定了运行时绝对地址）<br>2.加载时<br>3.运行时（If the process can be moved during its execution from one memory segment to another, then binding must be delayed until run time. Special hardware must be available for this scheme to work, as will be discussed in Section 8.1.3. Most general-purpose operating systems use this method.）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;内存管理&quot;&gt;&lt;a href=&quot;#内存管理&quot; class=&quot;headerlink&quot; title=&quot;内存管理&quot;&gt;&lt;/a&gt;内存管理&lt;/h1&gt;&lt;h2 id=&quot;连续内存管理&quot;&gt;&lt;a href=&quot;#连续内存管理&quot; class=&quot;headerlink&quot; title=&quot;连续内存管
      
    
    </summary>
    
    
      <category term="操作系统" scheme="http://kaisblog.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
      <category term="笔记" scheme="http://kaisblog.cn/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="Operating system" scheme="http://kaisblog.cn/tags/Operating-system/"/>
    
      <category term="Notes" scheme="http://kaisblog.cn/tags/Notes/"/>
    
  </entry>
  
  <entry>
    <title>c笔记</title>
    <link href="http://kaisblog.cn/2018/05/20/c%E7%AC%94%E8%AE%B0/"/>
    <id>http://kaisblog.cn/2018/05/20/c笔记/</id>
    <published>2018-05-20T01:45:49.930Z</published>
    <updated>2018-05-20T01:45:49.930Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">swap_manager</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     <span class="keyword">const</span> <span class="keyword">char</span> *name;</span><br><span class="line">     <span class="comment">/* Global initialization for the swap manager */</span></span><br><span class="line">     <span class="keyword">int</span> (*init)            (<span class="keyword">void</span>);</span><br><span class="line">     <span class="comment">/* Initialize the priv data inside mm_struct */</span></span><br><span class="line">     <span class="keyword">int</span> (*init_mm)         (struct mm_struct *mm);</span><br><span class="line">     <span class="comment">/* Called when tick interrupt occured */</span></span><br><span class="line">     <span class="keyword">int</span> (*tick_event)      (struct mm_struct *mm);</span><br><span class="line">     <span class="comment">/* Called when map a swappable page into the mm_struct */</span></span><br><span class="line">     <span class="keyword">int</span> (*map_swappable)   (struct mm_struct *mm, <span class="keyword">uintptr_t</span> addr, struct Page *page, <span class="keyword">int</span> swap_in);</span><br><span class="line">     <span class="comment">/* When a page is marked as shared, this routine is called to</span></span><br><span class="line"><span class="comment">      * delete the addr entry from the swap manager */</span></span><br><span class="line">     <span class="keyword">int</span> (*set_unswappable) (struct mm_struct *mm, <span class="keyword">uintptr_t</span> addr);</span><br><span class="line">     <span class="comment">/* Try to swap out a page, return then victim */</span></span><br><span class="line">     <span class="keyword">int</span> (*swap_out_victim) (struct mm_struct *mm, struct Page **ptr_page, <span class="keyword">int</span> in_tick);</span><br><span class="line">     <span class="comment">/* check the page relpacement algorithm */</span></span><br><span class="line">     <span class="keyword">int</span> (*check_swap)(<span class="keyword">void</span>);     </span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//可以多种实现。</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">swap_manager</span> <span class="title">swap_manager_fifo</span> =</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     .name            = <span class="string">"fifo swap manager"</span>,</span><br><span class="line">     .init            = &amp;_fifo_init,</span><br><span class="line">     .init_mm         = &amp;_fifo_init_mm,</span><br><span class="line">     .tick_event      = &amp;_fifo_tick_event,</span><br><span class="line">     .map_swappable   = &amp;_fifo_map_swappable,</span><br><span class="line">     .set_unswappable = &amp;_fifo_set_unswappable,</span><br><span class="line">     .swap_out_victim = &amp;_fifo_swap_out_victim,</span><br><span class="line">     .check_swap      = &amp;_fifo_check_swap,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">swap_manager</span> <span class="title">swap_manager_clock</span> =</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">     .name            = <span class="string">"clock swap manager"</span>,</span><br><span class="line">     .init            = &amp;_clock_init,</span><br><span class="line">     .init_mm         = &amp;_clock_init_mm,</span><br><span class="line">     .tick_event      = &amp;_clock_tick_event,</span><br><span class="line">     .map_swappable   = &amp;_clock_map_swappable,</span><br><span class="line">     .set_unswappable = &amp;_clock_set_unswappable,</span><br><span class="line">     .swap_out_victim = &amp;_clock_swap_out_victim,</span><br><span class="line">     .check_swap      = &amp;_clock_check_swap,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>链表<br><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_entry</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_entry</span> *<span class="title">prev</span>, *<span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">list_entry</span> <span class="title">list_entry_t</span>;</span></span><br><span class="line"></span><br><span class="line">list_init(<span class="keyword">list_entry_t</span> *elm) &#123;</span><br><span class="line">    elm-&gt;prev = elm-&gt;next = elm;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">list_add_before(<span class="keyword">list_entry_t</span> *listelm, <span class="keyword">list_entry_t</span> *elm) &#123;</span><br><span class="line">    __list_add(elm, listelm-&gt;prev, listelm);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">__list_add(<span class="keyword">list_entry_t</span> *elm, <span class="keyword">list_entry_t</span> *prev, <span class="keyword">list_entry_t</span> *next) &#123;</span><br><span class="line">    prev-&gt;next = next-&gt;prev = elm;</span><br><span class="line">    elm-&gt;next = next;</span><br><span class="line">    elm-&gt;prev = prev;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用，嵌入需要使用链表的数据结构</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ref;                        <span class="comment">// page frame's reference counter</span></span><br><span class="line">    <span class="keyword">uint32_t</span> flags;                 <span class="comment">// array of flags that describe the status of the page frame</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> property;          <span class="comment">// the num of free block, used in first fit pm manager</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> page_link;         <span class="comment">// free list link</span></span><br><span class="line">    <span class="keyword">list_entry_t</span> pra_page_link;     <span class="comment">// used for pra (page replace algorithm)</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> pra_vaddr;            <span class="comment">// used for pra (page replace algorithm)</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转为链表项</span></span><br><span class="line"><span class="keyword">list_entry_t</span> *entry=&amp;(page-&gt;pra_page_link);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转为包含数据结构</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> le2page(le, member)                 \</span></span><br><span class="line">    to_struct((le), struct Page, member)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* *</span></span><br><span class="line"><span class="comment"> * to_struct - get the struct from a ptr</span></span><br><span class="line"><span class="comment"> * @ptr:    a struct pointer of member</span></span><br><span class="line"><span class="comment"> * @type:   the type of the struct this is embedded in</span></span><br><span class="line"><span class="comment"> * @member: the name of the member within the struct</span></span><br><span class="line"><span class="comment"> * */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> to_struct(ptr, type, member)                               \</span></span><br><span class="line">    ((type *)((<span class="keyword">char</span> *)(ptr) - offsetof(type, member)))</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> offsetof(type, member)                                      \</span></span><br><span class="line">    ((<span class="keyword">size_t</span>)(&amp;((type *)<span class="number">0</span>)-&gt;member))</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Page</span> *<span class="title">p</span> = <span class="title">le2page</span>(<span class="title">le</span>, <span class="title">pra_page_link</span>);</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// （int *func(uint32_t[])）函数数组</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">int</span> <span class="params">(*syscalls[])</span><span class="params">(<span class="keyword">uint32_t</span> arg[])</span> </span>= &#123;</span><br><span class="line">    [SYS_exit]              sys_exit,</span><br><span class="line">    [SYS_fork]              sys_fork,</span><br><span class="line">    [SYS_wait]              sys_wait,</span><br><span class="line">    [SYS_exec]              sys_exec,</span><br><span class="line">    [SYS_yield]             sys_yield,</span><br><span class="line">    [SYS_kill]              sys_kill,</span><br><span class="line">    [SYS_getpid]            sys_getpid,</span><br><span class="line">    [SYS_putc]              sys_putc,</span><br><span class="line">    [SYS_pgdir]             sys_pgdir,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NUM_SYSCALLS        ((sizeof(syscalls)) / (sizeof(syscalls[0])))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span></span><br><span class="line">syscall(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">trapframe</span> *<span class="title">tf</span> = <span class="title">current</span>-&gt;<span class="title">tf</span>;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> arg[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">int</span> num = tf-&gt;tf_regs.reg_eax;</span><br><span class="line">    <span class="keyword">if</span> (num &gt;= <span class="number">0</span> &amp;&amp; num &lt; NUM_SYSCALLS) &#123;</span><br><span class="line">        <span class="keyword">if</span> (syscalls[num] != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            arg[<span class="number">0</span>] = tf-&gt;tf_regs.reg_edx;</span><br><span class="line">            arg[<span class="number">1</span>] = tf-&gt;tf_regs.reg_ecx;</span><br><span class="line">            arg[<span class="number">2</span>] = tf-&gt;tf_regs.reg_ebx;</span><br><span class="line">            arg[<span class="number">3</span>] = tf-&gt;tf_regs.reg_edi;</span><br><span class="line">            arg[<span class="number">4</span>] = tf-&gt;tf_regs.reg_esi;</span><br><span class="line">            tf-&gt;tf_regs.reg_eax = syscalls[num](arg);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    print_trapframe(tf);</span><br><span class="line">    panic(<span class="string">"undefined syscall %d, pid = %d, name = %s.\n"</span>,</span><br><span class="line">            num, current-&gt;pid, current-&gt;name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;
      
    
    </summary>
    
    
      <category term="Note" scheme="http://kaisblog.cn/tags/Note/"/>
    
      <category term="C" scheme="http://kaisblog.cn/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>SQL注入</title>
    <link href="http://kaisblog.cn/2018/05/20/SQL%E6%B3%A8%E5%85%A5/"/>
    <id>http://kaisblog.cn/2018/05/20/SQL注入/</id>
    <published>2018-05-20T01:45:49.929Z</published>
    <updated>2018-05-20T01:45:49.929Z</updated>
    
    <content type="html"><![CDATA[<h2 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h2><p>1.测试数据库表列数</p><pre><code>`select colA from table order by 1` 不断增加`order by`后面的数字，可以测试出table的表列数。</code></pre><p>2.查询数据库名字<code>select database()</code></p><p>3.查询当前用户<code>select user()</code></p><p>4.查询数据库版本<code>select version()</code></p><p>5.查询操作系统<code>select @@version_compile_os</code></p><p>6.数据库自带数据库为<code>information_schema</code> 其下包含tables表，包含所有创建的表，schema 为<code>table_name, table_schema</code></p><p>7.绕过验证</p><p> 原始验证的sql语句<code>select * from users where username=&#39;123&#39; and password=&#39;123&#39;</code></p><p> 注入代码<code>123&#39; or 1=1</code>到username字段</p><p> 实际执行代码<code>select * from users where username=&#39;123&#39; or 1=1 #&#39; and password=&#39;123&#39; or 1=1 #&#39;</code></p><p> 由于在where判断的时候 <code>1=1</code>恒为真，所以语句执行成功，查询到所有用户。</p><h2 id="SQL注入点判断方法"><a href="#SQL注入点判断方法" class="headerlink" title="SQL注入点判断方法"></a>SQL注入点判断方法</h2><h3 id="单引号判断法"><a href="#单引号判断法" class="headerlink" title="单引号判断法"></a>单引号判断法</h3><p> <code>http://xxx/abc.php?id=1&#39;</code> 查看页面是否出错，分为字符型和数字型。</p><h4 id="数字型"><a href="#数字型" class="headerlink" title="数字型"></a>数字型</h4><p> 1.使用<code>http://xxx/abc.php?id= x and 1=1</code>判断，页面正常运行</p><p> 2.使用<code>http://xxx/abc.php?id= x and 1=2</code>判断，页面出错</p><p> 若为字符型，则运行<br> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> &lt;表名&gt; <span class="keyword">where</span> <span class="keyword">id</span> = <span class="string">'x and 1=1'</span> </span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> &lt;表名&gt; <span class="keyword">where</span> <span class="keyword">id</span> = <span class="string">'x and 1=2'</span></span><br></pre></td></tr></table></figure></p><h4 id="字符型"><a href="#字符型" class="headerlink" title="字符型"></a>字符型</h4><p> 测试方法：</p><p> 1.<code>http://xxx/abc.php?id= x&#39; and &#39;1&#39;=&#39;1</code> 正常运行</p><p> 2.<code>http://xxx/abc.php?id= x&#39; and &#39;1&#39;=&#39;2</code>出错</p><p> 实际执行<code>select * from &lt;表名&gt; where id = &#39;x&#39; and &#39;1&#39;=&#39;1&#39;</code></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;基本操作&quot;&gt;&lt;a href=&quot;#基本操作&quot; class=&quot;headerlink&quot; title=&quot;基本操作&quot;&gt;&lt;/a&gt;基本操作&lt;/h2&gt;&lt;p&gt;1.测试数据库表列数&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;`select colA from table order by 1` 
      
    
    </summary>
    
    
      <category term="Note" scheme="http://kaisblog.cn/tags/Note/"/>
    
      <category term="CTF" scheme="http://kaisblog.cn/tags/CTF/"/>
    
      <category term="Security" scheme="http://kaisblog.cn/tags/Security/"/>
    
  </entry>
  
  <entry>
    <title>CTF经验总结</title>
    <link href="http://kaisblog.cn/2018/05/20/CTF%E7%BB%8F%E9%AA%8C%E6%80%BB%E7%BB%93/"/>
    <id>http://kaisblog.cn/2018/05/20/CTF经验总结/</id>
    <published>2018-05-20T01:45:49.928Z</published>
    <updated>2018-05-20T01:45:49.928Z</updated>
    
    <content type="html"><![CDATA[<h2 id="思考方向"><a href="#思考方向" class="headerlink" title="思考方向"></a>思考方向</h2><h3 id="字符串："><a href="#字符串：" class="headerlink" title="字符串："></a>字符串：</h3><p>形式：字符串末尾为= </p><p>方向：base64，base32，base16编码</p><p>形式：<strong>ocjp{zkirjwmo-ollj-nmlw-joxi-tmolnrnotvms}</strong></p><p>方向：<a href="https://cryptii.com/caesar-cipher" target="_blank" rel="external">凯撒密码</a>，<a href="https://cryptii.com/caesar-cipher" target="_blank" rel="external">弗吉尼亚密码</a>,猪圈密码</p><p>形式：<strong>fgkjol-ljimnoml{iw-lnwo-ortsazrmojm-xtlnv}</strong></p><p>方向：栅栏密码</p><p>形式：<strong>21232f297a57a5a743894a0e4a801fc3</strong></p><p>方向：16进制解码，MD5解密</p><p>形式：<strong>=E6=8A=80=E6=9C=AF=E6=9C=89=E6=B8=A9=E5=BA=A6</strong></p><p>方向：<a href="http://www.mxcz.net/tools/QuotedPrintable.aspx" target="_blank" rel="external">可打印字符编码</a>。类似百分号编码，代替%为=。百分号编码使用python <code>urllib.parse.unquote</code></p><p>形式：+++++ +++++ [-&gt;++ +++++ +++&lt;] &gt;++.+ +++++ .&lt;+++ [-&gt;– -&lt;]&gt;- -.+++ +++.&lt;</p><p>方向：<a href="https://www.splitbrain.org/services/ook" target="_blank" rel="external">brainfuck编程语言</a></p><h3 id="图片文件："><a href="#图片文件：" class="headerlink" title="图片文件："></a>图片文件：</h3><pre><code>1.用silentEye查隐写术2.用hxD查二进制内容是否包含flag3.用binwalk查看是否为多张图片</code></pre><h3 id="音频文件："><a href="#音频文件：" class="headerlink" title="音频文件："></a>音频文件：</h3><pre><code>1.silentEye查隐写术2.频谱分析</code></pre><h2 id="软件工具："><a href="#软件工具：" class="headerlink" title="软件工具："></a>软件工具：</h2><p><a href="http://www.cmd5.com/" target="_blank" rel="external">md5解密</a></p><p><a href="https://silenteye.v1kings.io/" target="_blank" rel="external">SilentEye</a></p><p><a href="https://mh-nexus.de/en/hxd/" target="_blank" rel="external">hxD</a></p><p><a href="https://cryptii.com/caesar-cipher" target="_blank" rel="external">各种古典密码解密</a></p><p>binwalk进行二进制文件的分析<br>安装：<code>sudo apt-get install binwalk</code></p><h2 id="工具脚本"><a href="#工具脚本" class="headerlink" title="工具脚本"></a>工具脚本</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#将16进制编码字符串转为ascii字符串</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#python3</span></span><br><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line">binascii.unhexlify(<span class="string">'666c61677b686578327374725f6368616c6c656e67657d'</span>)</span><br><span class="line">参数：<span class="number">16</span>进制字符串，</span><br><span class="line">返回值：bytes</span><br><span class="line"></span><br><span class="line"><span class="comment">#python2</span></span><br><span class="line"><span class="string">'666c61677b686578327374725f6368616c6c656e67657d'</span>.decode(<span class="string">'hex'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#计算与flag字符串差值</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calDiff</span><span class="params">(mstr, flag = <span class="string">"flag"</span>)</span>:</span></span><br><span class="line">    res = []</span><br><span class="line">    <span class="keyword">for</span> (i,c) <span class="keyword">in</span> enumerate(flag):</span><br><span class="line">        res.append(ord(mstr[i]) - ord(c))</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#猪圈密码解密</span></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    dic = &#123;<span class="string">'a'</span>: <span class="string">'j'</span>, <span class="string">'b'</span>: <span class="string">'k'</span>, <span class="string">'c'</span>: <span class="string">'l'</span>, <span class="string">'d'</span>: <span class="string">'m'</span>, <span class="string">'e'</span>: <span class="string">'n'</span>, <span class="string">'f'</span>: <span class="string">'o'</span>, <span class="string">'g'</span>: <span class="string">'p'</span>, <span class="string">'h'</span>: <span class="string">'q'</span>, <span class="string">'i'</span>: <span class="string">'r'</span>, <span class="string">'s'</span>: <span class="string">'w'</span>, <span class="string">'v'</span>: <span class="string">'z'</span>,</span><br><span class="line">           <span class="string">'t'</span>: <span class="string">'x'</span>, <span class="string">'u'</span>: <span class="string">'y'</span>, <span class="string">'j'</span>: <span class="string">'a'</span>, <span class="string">'k'</span>: <span class="string">'b'</span>, <span class="string">'l'</span>: <span class="string">'c'</span>, <span class="string">'m'</span>: <span class="string">'d'</span>, <span class="string">'n'</span>: <span class="string">'e'</span>, <span class="string">'o'</span>: <span class="string">'f'</span>, <span class="string">'p'</span>: <span class="string">'g'</span>, <span class="string">'q'</span>: <span class="string">'h'</span>, <span class="string">'r'</span>: <span class="string">'i'</span>,</span><br><span class="line">           <span class="string">'w'</span>: <span class="string">'s'</span>, <span class="string">'z'</span>: <span class="string">'v'</span>, <span class="string">'x'</span>: <span class="string">'t'</span>, <span class="string">'y'</span>: <span class="string">'u'</span>&#125;</span><br><span class="line">    crypto = sys.argv[<span class="number">1</span>]</span><br><span class="line">    plaintext = <span class="string">''</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> crypto:</span><br><span class="line">        <span class="keyword">if</span> c <span class="keyword">in</span> dic:</span><br><span class="line">            plaintext += dic[c]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            plaintext += c</span><br><span class="line">    print(plaintext)</span><br><span class="line"></span><br><span class="line"><span class="comment">#TODO 按照不同组合数解密栅栏密码</span></span><br><span class="line"><span class="comment">#TODO 凯撒密码解密,rotN</span></span><br></pre></td></tr></table></figure><p>其他工具：<br>python -m http.server</p><h4 id="出题办法"><a href="#出题办法" class="headerlink" title="出题办法"></a>出题办法</h4><p>1.根据编辑器窗口宽度改变ascii字符显示flag</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;思考方向&quot;&gt;&lt;a href=&quot;#思考方向&quot; class=&quot;headerlink&quot; title=&quot;思考方向&quot;&gt;&lt;/a&gt;思考方向&lt;/h2&gt;&lt;h3 id=&quot;字符串：&quot;&gt;&lt;a href=&quot;#字符串：&quot; class=&quot;headerlink&quot; title=&quot;字符串：&quot;&gt;&lt;/a
      
    
    </summary>
    
    
      <category term="Note" scheme="http://kaisblog.cn/tags/Note/"/>
    
      <category term="CTF" scheme="http://kaisblog.cn/tags/CTF/"/>
    
      <category term="security" scheme="http://kaisblog.cn/tags/security/"/>
    
      <category term="网络安全" scheme="http://kaisblog.cn/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>CPU调度</title>
    <link href="http://kaisblog.cn/2018/05/20/CPU%E8%B0%83%E5%BA%A6/"/>
    <id>http://kaisblog.cn/2018/05/20/CPU调度/</id>
    <published>2018-05-20T01:45:49.927Z</published>
    <updated>2018-05-20T01:45:49.928Z</updated>
    
    <content type="html"><![CDATA[<p>目的：CPU作为一种资源，应当提高利用率，合理利用。</p><p>发现：进程执行存在着CPU和IO周期，不断在使用CPU和IO操作间切换。IO瓶颈型进程多为短暂的CPU burst，CPU瓶颈型进程CPU burst较长。</p><p><img src="https://www.github.com/ChristopherKai/picsRepo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1521633568672.jpg" alt="CPU burst持续时间分布"></p><h2 id="CPU调度器"><a href="#CPU调度器" class="headerlink" title="CPU调度器"></a>CPU调度器</h2><p>职责：从就绪队列(ready queue)选择即将占用CPU的进程。就绪队列没必要以FIFO队列形式存在，可以是链表，优先队列，树等。</p><h2 id="抢占式调度-preemptive-scheduling"><a href="#抢占式调度-preemptive-scheduling" class="headerlink" title="抢占式调度 preemptive scheduling"></a>抢占式调度 preemptive scheduling</h2><p>非抢占式调度发生在：<br>    1.进程主动从运行态切换至等待态(IO操作或者wait()子进程)<br>    2.进程终结</p><p>抢占调度发生在：<br>    1.进程从运行态转为就绪态（比如发生中断）<br>    2.进程从等待态转为就绪态（比如IO完成）</p><p>抢占式调度必须依赖特定硬件环境才可实现，比如一个timer。</p><p>抢占调度带来的问题：<br>1.race condition，两个进程访问同一内存，发生抢占<br>2.内核设计。系统调用等。</p><h2 id="Dispatcher"><a href="#Dispatcher" class="headerlink" title="Dispatcher"></a>Dispatcher</h2><p>职责：<br>1.上下文切换<br>2.特权模式切换<br>3.重启进程</p><p>从一个进程切换到另外一个进程的时间被称为dispatch latency。</p><h2 id="调度算法评价指标"><a href="#调度算法评价指标" class="headerlink" title="调度算法评价指标"></a>调度算法评价指标</h2><p>1.CPU利用率。<br>2.吞吐量。单位时间内完成的进程数。<br>3.turnaround 时间：进程从加载到内存，就绪队列等待时间，CPU执行时间，IO等待时间。<br>4.等待时间：进程在就绪队列的等待时间。<br>5.响应时间。</p><p>一般来讲，倾向于最大化1.2.，最小化3.4.5.。研究发现，在交互式系统上，最小化响应时间的方差比最小化平均响应时间效果更好。因为一个有着合理并可预测响应时间的交互式系统更好用。</p><h2 id="调度算法"><a href="#调度算法" class="headerlink" title="调度算法"></a>调度算法</h2><h3 id="FCFS"><a href="#FCFS" class="headerlink" title="FCFS"></a>FCFS</h3><p>First Come First Serve算法：先请求CPU的先使用CPU。</p><p>实现：FIFO队列。<br>抢占式：否<br>缺点：convoy effect</p><h3 id="SJF"><a href="#SJF" class="headerlink" title="SJF"></a>SJF</h3><p>Shortest Job First算法：按照进程下次使用CPU的时长，最小的优先使用CPU。</p><p>别名：shortest-nextCPU-burst算法。<br>实现：优先队列<br>抢占式：是<br>备注：短期调度器实现困难，因为进程的下一次CPU burst难以预估。在长期调度器中使用频繁。</p><p>Un+1 = a * tn +　(1 - a)Un 指数平均数，根据历史估测和历史CPU burst时长来来估算下一次CPU burst。</p><h3 id="Priority-Scheduling"><a href="#Priority-Scheduling" class="headerlink" title="Priority Scheduling"></a>Priority Scheduling</h3><p>实现：优先队列<br>抢占式：不定，可以抢占CPU或者仅仅放入优先队列</p><p>优先队列调度会产生饥饿，即一些进程永远得不到CPU时间。解决办法，引入aging，随着时间增加，提升进程优先级，最终低优先级进程会得到执行。</p><h3 id="Round-Robin"><a href="#Round-Robin" class="headerlink" title="Round-Robin"></a>Round-Robin</h3><p>Round-Robin：队列内所有进程分配特定大小时间片，进程执行时间小于该时间片，切换到下一个进程，进程执行时间长于该时间将被下一个进程抢占CPU。</p><p>抢占式：是<br>实现：循环队列</p><p>在时间片很大情况下，退化为FCFS算法。</p><h3 id="多级队列-MQ"><a href="#多级队列-MQ" class="headerlink" title="多级队列 MQ"></a>多级队列 MQ</h3><p>根据进程特性分配到不同队列，各个队列有各自的调度算法，队列间存在优先级，进程无法在队列间切换优先级。</p><h3 id="多级反馈队列"><a href="#多级反馈队列" class="headerlink" title="多级反馈队列"></a>多级反馈队列</h3><p>进程优先级会在各个队列间移动。结果：IO密集型会在高优先级队列，CPU密集型会在低优先级队列。</p><h2 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h2><h3 id="PCS-Process-Contention-Scope"><a href="#PCS-Process-Contention-Scope" class="headerlink" title="PCS (Process Contention Scope)"></a>PCS (Process Contention Scope)</h3><p>在多对一，多对多线程模型下，多个用户线程互相竞争分配到内核线程的机会，所以，竞争范围为一个进程内，为PCS。</p><h3 id="SCS-System-Contention-Scope"><a href="#SCS-System-Contention-Scope" class="headerlink" title="SCS (System Contention Scope)"></a>SCS (System Contention Scope)</h3><p>内核线程一起竞争CPU，竞争范围为SCS。</p><h3 id="POSIX-设置竞争范围api"><a href="#POSIX-设置竞争范围api" class="headerlink" title="POSIX 设置竞争范围api"></a>POSIX 设置竞争范围api</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// scope 可选值PTHREAD_SCOPE_PROCESS,PTHREAD_SCOPE_SYSTEM</span></span><br><span class="line">pthread_attr_setscope(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">int</span> scope)</span><br><span class="line">pthread_attr_getscope(<span class="keyword">pthread_attr_t</span> *attr, <span class="keyword">int</span> *scope)</span><br></pre></td></tr></table></figure><p>在Linux和Mac OS上只支持PTHREAD_SCOPE_SYSTEM。</p><h2 id="多处理器调度"><a href="#多处理器调度" class="headerlink" title="多处理器调度"></a>多处理器调度</h2><p>主要目标负载共享，load sharing。</p><p>SMP:symmetric multiprocessing</p><h2 id="Processor-Affinity-进程亲和性"><a href="#Processor-Affinity-进程亲和性" class="headerlink" title="Processor Affinity 进程亲和性"></a>Processor Affinity 进程亲和性</h2><p>定义：进程偏向当前正在执行的处理器。<br>原因：每个处理器都有自己的缓存cache。当一个进程从一个CPU调度到另一个CPU的时候，原CPU和该进程有关的缓存必须invalidate，调度到的CPU的缓存必须重新产生，这样，调度的时候最好不要将进程跨处理器调度，降低cache更新的成本。</p><p>soft affinity：尽量使进程一直运行在一个处理器上，但不保证一直运行在一个处理器上。<br>hard affinity：操作系统提供syscall，让进程只运行在一部分处理器上。</p><p>eg. Linux实现了soft affinity，但是可用<code>sched_setaffinity()</code>设置hard affinity。</p><h2 id="Load-Balancing-负载均衡"><a href="#Load-Balancing-负载均衡" class="headerlink" title="Load Balancing 负载均衡"></a>Load Balancing 负载均衡</h2><p>Load balancing试图使工作量在处理器间均匀分布。<br>在每个处理器有私有调度队列时，load balancing是必要的。而所有处理器共享调度队列时，load balacing不必要，调度器会自动将工作分摊给空闲处理器。当代支持SMP的操作系统大多有各自的调度队列。 </p><p>load balacing 的两种办法: push migration,pull migration。这两种并不排斥，linux上同时实现了两者。</p><h3 id="push-migration"><a href="#push-migration" class="headerlink" title="push migration"></a>push migration</h3><p>push migration: 特定任务周期性检测各个处理器负载，主动将进程均匀分布。</p><h3 id="pull-miragtion"><a href="#pull-miragtion" class="headerlink" title="pull miragtion"></a>pull miragtion</h3><p>pull migration: 空闲处理器主动将忙处理器的等待进程拉取。</p><p>Note.  维持负载均衡的过程中，有违处理器亲和性Processor Affinity。</p><h2 id="多核处理器"><a href="#多核处理器" class="headerlink" title="多核处理器"></a>多核处理器</h2><p>memeory stall: cpu访问内存，等待数据可用的时间。</p><p>// TODO </p><h2 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h2><p>Soft real-time system： 不保证critical进程何时被调度，但保证critical进程会比non critical进程优先。</p><p>Hard real-time system： 保证进程在期限前完成。超出期限则等同于没有服务。</p><p>实时操作系统是事件驱动的，事件可能是软件的（时间中断）或者硬件的(汽车探测到路障)。</p><p>event latency：事件发生到收到服务的时间。必须保证这段时间内事件得到服务，否则超过期限，服务将无意义。</p><p>// TODO</p><h3 id="POSIX-实时调度api"><a href="#POSIX-实时调度api" class="headerlink" title="POSIX 实时调度api"></a>POSIX 实时调度api</h3><h2 id="操作系统实例"><a href="#操作系统实例" class="headerlink" title="操作系统实例"></a>操作系统实例</h2><h3 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h3><p>版本v2.5以前使用unix调度算法的变体。v2.5开始使用O(1)的调度算法，开始支持SMP，处理器亲和性，负载均衡。由于对交互式进程支持不够好，重新设计了Completely Fair Scheduler（CFS）调度算法。</p><p>调度基于调度类scheduling class。scheduling class有不同的优先级。标准linux实现了两种调度类：1.CFS 2.realtime 。为了决定哪个进程占用cpu，调度器从高优先级的调度类内选择高优先级的进程。</p><h4 id="CFS"><a href="#CFS" class="headerlink" title="CFS"></a>CFS</h4><p>不具体根据优先级分配时间片大小，CFS分配一定比例cpu时间。该比例的计算依据nice值，nice取值范围-20 到19，越小优先级越高，分配cpu比例更多，缺省值为0。nice的意思是一个进程越nice，对其他进程越nice，让给其他进程更多cpu。<br>CFS使用目标延迟(target latency)分配时间，target latency即进程在至少运行一次的时间间隔。目标延迟除了有缺省值，最小值，其会随着进程数量增加而增加。</p><p>CFS会记录进程运行时间，用虚拟运行时间vruntime。进程优先级决定了衰减因子(decay factor)，优先级越低衰减因子越大。对缺省nice值0，虚拟运行时间vruntime等于实际运行时间。低优先级进程若vruntime 200ms，实际运行时间会小于200ms。高优先级进程若vruntime为200ms，实际运行时间大于200ms。<br>调度时，选择vruntime较小的进程，而且高优先级进程会抢占低优先级进程。</p><p>具体分析：<br>比如，两个nice值一样的进程，一个IO密集型，一个CPU密集型。一般第一个进程只会运行短暂时间，第二个则会耗尽时间片。所有，第一个进程的vruntime会比第二个小，优先调度。在第二个进程运行时，若第一个进程IO请求返回时，则会抢占CPU。</p><p>实现：<br>按照进程vruntime作为key组织进程红黑树，就绪队列。</p><p><img src="https://www.github.com/ChristopherKai/picsRepo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1522417224584.jpg" alt="vruntime红黑树"></p><h4 id="realtime"><a href="#realtime" class="headerlink" title="realtime"></a>realtime</h4><p>任何SCHED_FIFO 或SCHED_RR任务优先级高于非实时任务。实时任务优先级静态映射0-99，非实时任务的nice值-20映射100,19映射139。</p><p><img src="https://www.github.com/ChristopherKai/picsRepo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1522418549196.jpg" alt="Linux进程优先级"></p><h3 id="windows"><a href="#windows" class="headerlink" title="windows"></a>windows</h3><p>windows使用基于优先级的抢占式调度算法。其确保最高优先级进程一直运行。内核调度模块被称为Dispatcher。最高优先级进程会一直运行直到，被更高优先级进程抢占，终止，IO请求，时间片耗尽。</p><p>优先级分为12档。两类优先级：1.可变 variable class 2.realtime class。<br>第一类 ， 1-15。 第二类，16 - 30。（优先级0用来内存管理线程）。Dispatcher从队列选择高优先级进程，若无执行idle进程。<br>windos api定义了6类进程优先级，默认NORMAL_PRIORITY_CLASS。<code>SetPriorityClass()</code>设置优先级。除了REALTIME_PRIORITY_CLASS外，优先级类都可修改，即 variable class。</p><p>一个线程优先级由其所属优先级类和相对优先级共同决定。</p><p><img src="https://www.github.com/ChristopherKai/picsRepo/raw/master/%E5%B0%8F%E4%B9%A6%E5%8C%A0/1522420303976.jpg" alt="windos进程优先级"></p><h2 id="算法评估"><a href="#算法评估" class="headerlink" title="算法评估"></a>算法评估</h2><p>// TODO</p><h2 id="优先级反置"><a href="#优先级反置" class="headerlink" title="优先级反置"></a>优先级反置</h2><p>// TODO!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;目的：CPU作为一种资源，应当提高利用率，合理利用。&lt;/p&gt;
&lt;p&gt;发现：进程执行存在着CPU和IO周期，不断在使用CPU和IO操作间切换。IO瓶颈型进程多为短暂的CPU burst，CPU瓶颈型进程CPU burst较长。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https:/
      
    
    </summary>
    
    
      <category term="Note" scheme="http://kaisblog.cn/tags/Note/"/>
    
      <category term="Operating System" scheme="http://kaisblog.cn/tags/Operating-System/"/>
    
      <category term="操作系统" scheme="http://kaisblog.cn/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>消息摘要、数字签名与CA证书</title>
    <link href="http://kaisblog.cn/2017/11/24/%E6%95%B0%E5%AD%97%E7%AD%BE%E5%90%8D/"/>
    <id>http://kaisblog.cn/2017/11/24/数字签名/</id>
    <published>2017-11-24T08:08:39.000Z</published>
    <updated>2018-05-20T01:45:49.934Z</updated>
    
    <content type="html"><![CDATA[<h2 id="消息摘要"><a href="#消息摘要" class="headerlink" title="消息摘要"></a>消息摘要</h2><p>  对一段文本进行hash，文本发生很小改变，hash也会改变。</p><h2 id="数字签名"><a href="#数字签名" class="headerlink" title="数字签名"></a>数字签名</h2><p>  基于非对称加密算法。<br>  权且将需要签名端称作服务端，先生成密钥对，将需要签名文本生成消息摘要，用<strong>私钥</strong>将摘要加密，加密后的摘要称作签体，<br>  将原文本、公钥、签体发送到客户端，客户端将签体用公钥解密得到消息摘要A，将原文本用相同消息摘要算法计算得到消息摘要B，消息摘要A和B相同则文本<strong>完整</strong>，<strong>无篡改</strong>，加密传输保证<em>无嗅探</em>，只有服务器拥有私钥保证了<em>不可抵赖性</em>。</p><h2 id="CA证书"><a href="#CA证书" class="headerlink" title="CA证书"></a>CA证书</h2><p>  上述加密算法保证了保密性，但是不可抵抗中间人攻击。<br>  中间人攻击原理：伪造服务器公钥，伪装成服务器回复客户端。<br>  所以有了CA证书。CA：certificate authority。根证书颁发机构可信性、所有客户端都安装有根证书是一切的前提。需要保证自身合法性的机构付费向根证书颁发机构购买证书，证书包含内容大致包括：<br>  1.申请机构的公钥X 2.申请机构的信息3.CA机构信息4.由CA机构的私钥加密申请机构公钥X生成的数字签名。<br>  在客户端请求连接后，服务器先发来CA证书，由于已经安装CA机构证书可以通过CA机构公钥解密公钥X得到数字签名，验证是否合法。如果合法，就可以使用公钥X和服务器通信了。</p><p>  如果中间人想要伪装，可以1，也可以伪造2，,也可以伪造3，但是由于没有CA机构的私钥，永远无法伪造<strong>伪造的申请机构的公钥X</strong>的数字签名！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;消息摘要&quot;&gt;&lt;a href=&quot;#消息摘要&quot; class=&quot;headerlink&quot; title=&quot;消息摘要&quot;&gt;&lt;/a&gt;消息摘要&lt;/h2&gt;&lt;p&gt;  对一段文本进行hash，文本发生很小改变，hash也会改变。&lt;/p&gt;
&lt;h2 id=&quot;数字签名&quot;&gt;&lt;a href=&quot;#数
      
    
    </summary>
    
    
      <category term="development" scheme="http://kaisblog.cn/tags/development/"/>
    
      <category term="security" scheme="http://kaisblog.cn/tags/security/"/>
    
      <category term="python" scheme="http://kaisblog.cn/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python的二进制数据类型</title>
    <link href="http://kaisblog.cn/2017/11/18/python%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://kaisblog.cn/2017/11/18/python的二进制数据类型/</id>
    <published>2017-11-18T14:30:33.000Z</published>
    <updated>2018-05-20T01:45:49.932Z</updated>
    
    <content type="html"><![CDATA[<p>#bytes,bytearray,memoryview</p><p>##bytes<br>Bytes 不可变的字节序列 ，可以视作整数数组，比如b[0] 返回一个整数<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">b'still allows embedded "double" quotes'</span></span><br><span class="line">bytes(<span class="number">10</span>)</span><br><span class="line">bytes(range(<span class="number">20</span>))</span><br><span class="line">bytes(obj) <span class="comment">#obj 遵循buffer protocol的二进制对象</span></span><br></pre></td></tr></table></figure></p><p>只能用ascii表示（0-255），大于127必须逃逸</p><p>##bytearray<br>bytes 的可变形式。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bytearray()</span><br><span class="line">bytearray(<span class="number">10</span>)</span><br><span class="line">bytearray(range(<span class="number">20</span>))</span><br><span class="line">bytearray(<span class="string">b'Hi!'</span>)</span><br></pre></td></tr></table></figure></p><p>两种对象都有类似其他序列对象的api</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="string">b"abc"</span></span><br><span class="line">b = a.replace(<span class="string">b"a"</span>, <span class="string">b"f"</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#bytes,bytearray,memoryview&lt;/p&gt;
&lt;p&gt;##bytes&lt;br&gt;Bytes 不可变的字节序列 ，可以视作整数数组，比如b[0] 返回一个整数&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td c
      
    
    </summary>
    
    
      <category term="development" scheme="http://kaisblog.cn/tags/development/"/>
    
      <category term="python" scheme="http://kaisblog.cn/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>kais-blog!</title>
    <link href="http://kaisblog.cn/2017/11/11/kais-blog/"/>
    <id>http://kaisblog.cn/2017/11/11/kais-blog/</id>
    <published>2017-11-11T08:32:56.000Z</published>
    <updated>2018-05-20T01:45:49.931Z</updated>
    
    <content type="html"><![CDATA[<ul><li>dev</li><li>photography</li><li>thoughts</li><li>cusine</li><li>…</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;dev&lt;/li&gt;
&lt;li&gt;photography&lt;/li&gt;
&lt;li&gt;thoughts&lt;/li&gt;
&lt;li&gt;cusine&lt;/li&gt;
&lt;li&gt;…&lt;/li&gt;
&lt;/ul&gt;

      
    
    </summary>
    
    
  </entry>
  
</feed>
